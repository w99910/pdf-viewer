import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper
} from "./chunk-QJQ2N2BE.js";

// node_modules/pdfjs-dist/web/pdf_viewer.js
var require_pdf_viewer = __commonJS({
  "node_modules/pdfjs-dist/web/pdf_viewer.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = root.pdfjsViewer = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/web/pdf_viewer", [], () => {
          return root.pdfjsViewer = factory();
        });
      else if (typeof exports === "object")
        exports["pdfjs-dist/web/pdf_viewer"] = root.pdfjsViewer = factory();
      else
        root["pdfjs-dist/web/pdf_viewer"] = root.pdfjsViewer = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _state, _updateMatchesCountOnProgress, _visitedPagesCount, _onFind, onFind_fn, _reset, reset_fn, _query, query_get, _shouldDirtyMatch, shouldDirtyMatch_fn, _isEntireWord, isEntireWord_fn, _calculateRegExpMatch, calculateRegExpMatch_fn, _convertToRegExpString, convertToRegExpString_fn, _calculateMatch, calculateMatch_fn, _extractText, extractText_fn, _updatePage, updatePage_fn, _updateAllPages, updateAllPages_fn, _nextMatch, nextMatch_fn, _matchesReady, matchesReady_fn, _nextPageMatch, nextPageMatch_fn, _advanceOffsetPage, advanceOffsetPage_fn, _updateMatch, updateMatch_fn, _onFindBarClose, onFindBarClose_fn, _requestMatchesCount, requestMatchesCount_fn, _updateUIResultsCount, updateUIResultsCount_fn, _updateUIState, updateUIState_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFindController = exports2.FindState = void 0;
              var _ui_utils = __w_pdfjs_require__2(2);
              var _pdf_find_utils = __w_pdfjs_require__2(3);
              var _pdfjsLib = __w_pdfjs_require__2(4);
              const FindState = {
                FOUND: 0,
                NOT_FOUND: 1,
                WRAPPED: 2,
                PENDING: 3
              };
              exports2.FindState = FindState;
              const FIND_TIMEOUT = 250;
              const MATCH_SCROLL_OFFSET_TOP = -50;
              const MATCH_SCROLL_OFFSET_LEFT = -400;
              const CHARACTERS_TO_NORMALIZE = {
                "‐": "-",
                "‘": "'",
                "’": "'",
                "‚": "'",
                "‛": "'",
                "“": '"',
                "”": '"',
                "„": '"',
                "‟": '"',
                "¼": "1/4",
                "½": "1/2",
                "¾": "3/4"
              };
              const DIACRITICS_EXCEPTION = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
              let DIACRITICS_EXCEPTION_STR;
              const DIACRITICS_REG_EXP = /\p{M}+/gu;
              const SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu;
              const NOT_DIACRITIC_FROM_END_REG_EXP = /([^\p{M}])\p{M}*$/u;
              const NOT_DIACRITIC_FROM_START_REG_EXP = /^\p{M}*([^\p{M}])/u;
              const SYLLABLES_REG_EXP = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g;
              const SYLLABLES_LENGTHS = /* @__PURE__ */ new Map();
              const FIRST_CHAR_SYLLABLES_REG_EXP = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]";
              const NFKC_CHARS_TO_NORMALIZE = /* @__PURE__ */ new Map();
              let noSyllablesRegExp = null;
              let withSyllablesRegExp = null;
              function normalize(text) {
                const syllablePositions = [];
                let m;
                while ((m = SYLLABLES_REG_EXP.exec(text)) !== null) {
                  let {
                    index
                  } = m;
                  for (const char of m[0]) {
                    let len = SYLLABLES_LENGTHS.get(char);
                    if (!len) {
                      len = char.normalize("NFD").length;
                      SYLLABLES_LENGTHS.set(char, len);
                    }
                    syllablePositions.push([len, index++]);
                  }
                }
                let normalizationRegex;
                if (syllablePositions.length === 0 && noSyllablesRegExp) {
                  normalizationRegex = noSyllablesRegExp;
                } else if (syllablePositions.length > 0 && withSyllablesRegExp) {
                  normalizationRegex = withSyllablesRegExp;
                } else {
                  const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
                  const toNormalizeWithNFKC = (0, _pdf_find_utils.getNormalizeWithNFKC)();
                  const CJK = "(?:\\p{Ideographic}|[぀-ヿ])";
                  const HKDiacritics = "(?:゙|゚)";
                  const regexp = `([${replace}])|([${toNormalizeWithNFKC}])|(${HKDiacritics}\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|(${CJK}\\n)|(\\n)`;
                  if (syllablePositions.length === 0) {
                    normalizationRegex = noSyllablesRegExp = new RegExp(regexp + "|(\\u0000)", "gum");
                  } else {
                    normalizationRegex = withSyllablesRegExp = new RegExp(regexp + `|(${FIRST_CHAR_SYLLABLES_REG_EXP})`, "gum");
                  }
                }
                const rawDiacriticsPositions = [];
                while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) {
                  rawDiacriticsPositions.push([m[0].length, m.index]);
                }
                let normalized = text.normalize("NFD");
                const positions = [[0, 0]];
                let rawDiacriticsIndex = 0;
                let syllableIndex = 0;
                let shift = 0;
                let shiftOrigin = 0;
                let eol = 0;
                let hasDiacritics = false;
                normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, p5, p6, p7, p8, i) => {
                  var _a, _b, _c;
                  i -= shiftOrigin;
                  if (p1) {
                    const replacement = CHARACTERS_TO_NORMALIZE[p1];
                    const jj = replacement.length;
                    for (let j = 1; j < jj; j++) {
                      positions.push([i - shift + j, shift - j]);
                    }
                    shift -= jj - 1;
                    return replacement;
                  }
                  if (p2) {
                    let replacement = NFKC_CHARS_TO_NORMALIZE.get(p2);
                    if (!replacement) {
                      replacement = p2.normalize("NFKC");
                      NFKC_CHARS_TO_NORMALIZE.set(p2, replacement);
                    }
                    const jj = replacement.length;
                    for (let j = 1; j < jj; j++) {
                      positions.push([i - shift + j, shift - j]);
                    }
                    shift -= jj - 1;
                    return replacement;
                  }
                  if (p3) {
                    hasDiacritics = true;
                    if (i + eol === ((_a = rawDiacriticsPositions[rawDiacriticsIndex]) == null ? void 0 : _a[1])) {
                      ++rawDiacriticsIndex;
                    } else {
                      positions.push([i - 1 - shift + 1, shift - 1]);
                      shift -= 1;
                      shiftOrigin += 1;
                    }
                    positions.push([i - shift + 1, shift]);
                    shiftOrigin += 1;
                    eol += 1;
                    return p3.charAt(0);
                  }
                  if (p4) {
                    const hasTrailingDashEOL = p4.endsWith("\n");
                    const len = hasTrailingDashEOL ? p4.length - 2 : p4.length;
                    hasDiacritics = true;
                    let jj = len;
                    if (i + eol === ((_b = rawDiacriticsPositions[rawDiacriticsIndex]) == null ? void 0 : _b[1])) {
                      jj -= rawDiacriticsPositions[rawDiacriticsIndex][0];
                      ++rawDiacriticsIndex;
                    }
                    for (let j = 1; j <= jj; j++) {
                      positions.push([i - 1 - shift + j, shift - j]);
                    }
                    shift -= jj;
                    shiftOrigin += jj;
                    if (hasTrailingDashEOL) {
                      i += len - 1;
                      positions.push([i - shift + 1, 1 + shift]);
                      shift += 1;
                      shiftOrigin += 1;
                      eol += 1;
                      return p4.slice(0, len);
                    }
                    return p4;
                  }
                  if (p5) {
                    const len = p5.length - 2;
                    positions.push([i - shift + len, 1 + shift]);
                    shift += 1;
                    shiftOrigin += 1;
                    eol += 1;
                    return p5.slice(0, -2);
                  }
                  if (p6) {
                    const len = p6.length - 1;
                    positions.push([i - shift + len, shift]);
                    shiftOrigin += 1;
                    eol += 1;
                    return p6.slice(0, -1);
                  }
                  if (p7) {
                    positions.push([i - shift + 1, shift - 1]);
                    shift -= 1;
                    shiftOrigin += 1;
                    eol += 1;
                    return " ";
                  }
                  if (i + eol === ((_c = syllablePositions[syllableIndex]) == null ? void 0 : _c[1])) {
                    const newCharLen = syllablePositions[syllableIndex][0] - 1;
                    ++syllableIndex;
                    for (let j = 1; j <= newCharLen; j++) {
                      positions.push([i - (shift - j), shift - j]);
                    }
                    shift -= newCharLen;
                    shiftOrigin += newCharLen;
                  }
                  return p8;
                });
                positions.push([normalized.length, shift]);
                return [normalized, positions, hasDiacritics];
              }
              function getOriginalIndex(diffs, pos, len) {
                if (!diffs) {
                  return [pos, len];
                }
                const start = pos;
                const end = pos + len - 1;
                let i = (0, _ui_utils.binarySearchFirstItem)(diffs, (x) => x[0] >= start);
                if (diffs[i][0] > start) {
                  --i;
                }
                let j = (0, _ui_utils.binarySearchFirstItem)(diffs, (x) => x[0] >= end, i);
                if (diffs[j][0] > end) {
                  --j;
                }
                const oldStart = start + diffs[i][1];
                const oldEnd = end + diffs[j][1];
                const oldLen = oldEnd + 1 - oldStart;
                return [oldStart, oldLen];
              }
              class PDFFindController {
                constructor({
                  linkService,
                  eventBus,
                  updateMatchesCountOnProgress = true
                }) {
                  __privateAdd(this, _onFind);
                  __privateAdd(this, _reset);
                  __privateAdd(this, _query);
                  __privateAdd(this, _shouldDirtyMatch);
                  __privateAdd(this, _isEntireWord);
                  __privateAdd(this, _calculateRegExpMatch);
                  __privateAdd(this, _convertToRegExpString);
                  __privateAdd(this, _calculateMatch);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _updatePage);
                  __privateAdd(this, _updateAllPages);
                  __privateAdd(this, _nextMatch);
                  __privateAdd(this, _matchesReady);
                  __privateAdd(this, _nextPageMatch);
                  __privateAdd(this, _advanceOffsetPage);
                  __privateAdd(this, _updateMatch);
                  __privateAdd(this, _onFindBarClose);
                  __privateAdd(this, _requestMatchesCount);
                  __privateAdd(this, _updateUIResultsCount);
                  __privateAdd(this, _updateUIState);
                  __privateAdd(this, _state, null);
                  __privateAdd(this, _updateMatchesCountOnProgress, true);
                  __privateAdd(this, _visitedPagesCount, 0);
                  this._linkService = linkService;
                  this._eventBus = eventBus;
                  __privateSet(this, _updateMatchesCountOnProgress, updateMatchesCountOnProgress);
                  this.onIsPageVisible = null;
                  __privateMethod(this, _reset, reset_fn).call(this);
                  eventBus._on("find", __privateMethod(this, _onFind, onFind_fn).bind(this));
                  eventBus._on("findbarclose", __privateMethod(this, _onFindBarClose, onFindBarClose_fn).bind(this));
                }
                get highlightMatches() {
                  return this._highlightMatches;
                }
                get pageMatches() {
                  return this._pageMatches;
                }
                get pageMatchesLength() {
                  return this._pageMatchesLength;
                }
                get selected() {
                  return this._selected;
                }
                get state() {
                  return __privateGet(this, _state);
                }
                setDocument(pdfDocument) {
                  if (this._pdfDocument) {
                    __privateMethod(this, _reset, reset_fn).call(this);
                  }
                  if (!pdfDocument) {
                    return;
                  }
                  this._pdfDocument = pdfDocument;
                  this._firstPageCapability.resolve();
                }
                scrollMatchIntoView({
                  element = null,
                  selectedLeft = 0,
                  pageIndex = -1,
                  matchIndex = -1
                }) {
                  if (!this._scrollMatches || !element) {
                    return;
                  } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
                    return;
                  } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
                    return;
                  }
                  this._scrollMatches = false;
                  const spot = {
                    top: MATCH_SCROLL_OFFSET_TOP,
                    left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT
                  };
                  (0, _ui_utils.scrollIntoView)(element, spot, true);
                }
              }
              _state = new WeakMap();
              _updateMatchesCountOnProgress = new WeakMap();
              _visitedPagesCount = new WeakMap();
              _onFind = new WeakSet();
              onFind_fn = function(state) {
                if (!state) {
                  return;
                }
                if (state.phraseSearch === false) {
                  console.error("The `phraseSearch`-parameter was removed, please provide an Array of strings in the `query`-parameter instead.");
                  if (typeof state.query === "string") {
                    state.query = state.query.match(/\S+/g);
                  }
                }
                const pdfDocument = this._pdfDocument;
                const {
                  type
                } = state;
                if (__privateGet(this, _state) === null || __privateMethod(this, _shouldDirtyMatch, shouldDirtyMatch_fn).call(this, state)) {
                  this._dirtyMatch = true;
                }
                __privateSet(this, _state, state);
                if (type !== "highlightallchange") {
                  __privateMethod(this, _updateUIState, updateUIState_fn).call(this, FindState.PENDING);
                }
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  __privateMethod(this, _extractText, extractText_fn).call(this);
                  const findbarClosed = !this._highlightMatches;
                  const pendingTimeout = !!this._findTimeout;
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (!type) {
                    this._findTimeout = setTimeout(() => {
                      __privateMethod(this, _nextMatch, nextMatch_fn).call(this);
                      this._findTimeout = null;
                    }, FIND_TIMEOUT);
                  } else if (this._dirtyMatch) {
                    __privateMethod(this, _nextMatch, nextMatch_fn).call(this);
                  } else if (type === "again") {
                    __privateMethod(this, _nextMatch, nextMatch_fn).call(this);
                    if (findbarClosed && __privateGet(this, _state).highlightAll) {
                      __privateMethod(this, _updateAllPages, updateAllPages_fn).call(this);
                    }
                  } else if (type === "highlightallchange") {
                    if (pendingTimeout) {
                      __privateMethod(this, _nextMatch, nextMatch_fn).call(this);
                    } else {
                      this._highlightMatches = true;
                    }
                    __privateMethod(this, _updateAllPages, updateAllPages_fn).call(this);
                  } else {
                    __privateMethod(this, _nextMatch, nextMatch_fn).call(this);
                  }
                });
              };
              _reset = new WeakSet();
              reset_fn = function() {
                this._highlightMatches = false;
                this._scrollMatches = false;
                this._pdfDocument = null;
                this._pageMatches = [];
                this._pageMatchesLength = [];
                __privateSet(this, _visitedPagesCount, 0);
                __privateSet(this, _state, null);
                this._selected = {
                  pageIdx: -1,
                  matchIdx: -1
                };
                this._offset = {
                  pageIdx: null,
                  matchIdx: null,
                  wrapped: false
                };
                this._extractTextPromises = [];
                this._pageContents = [];
                this._pageDiffs = [];
                this._hasDiacritics = [];
                this._matchesCountTotal = 0;
                this._pagesToSearch = null;
                this._pendingFindMatches = /* @__PURE__ */ new Set();
                this._resumePageIdx = null;
                this._dirtyMatch = false;
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
                this._firstPageCapability = new _pdfjsLib.PromiseCapability();
              };
              _query = new WeakSet();
              query_get = function() {
                const {
                  query
                } = __privateGet(this, _state);
                if (typeof query === "string") {
                  if (query !== this._rawQuery) {
                    this._rawQuery = query;
                    [this._normalizedQuery] = normalize(query);
                  }
                  return this._normalizedQuery;
                }
                return (query || []).filter((q) => !!q).map((q) => normalize(q)[0]);
              };
              _shouldDirtyMatch = new WeakSet();
              shouldDirtyMatch_fn = function(state) {
                var _a;
                const newQuery = state.query, prevQuery = __privateGet(this, _state).query;
                const newType = typeof newQuery, prevType = typeof prevQuery;
                if (newType !== prevType) {
                  return true;
                }
                if (newType === "string") {
                  if (newQuery !== prevQuery) {
                    return true;
                  }
                } else if (JSON.stringify(newQuery) !== JSON.stringify(prevQuery)) {
                  return true;
                }
                switch (state.type) {
                  case "again":
                    const pageNumber = this._selected.pageIdx + 1;
                    const linkService = this._linkService;
                    return pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !(((_a = this.onIsPageVisible) == null ? void 0 : _a.call(this, pageNumber)) ?? true);
                  case "highlightallchange":
                    return false;
                }
                return true;
              };
              _isEntireWord = new WeakSet();
              isEntireWord_fn = function(content, startIdx, length) {
                let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);
                if (match) {
                  const first = content.charCodeAt(startIdx);
                  const limit = match[1].charCodeAt(0);
                  if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);
                if (match) {
                  const last = content.charCodeAt(startIdx + length - 1);
                  const limit = match[1].charCodeAt(0);
                  if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                return true;
              };
              _calculateRegExpMatch = new WeakSet();
              calculateRegExpMatch_fn = function(query, entireWord, pageIndex, pageContent) {
                const matches = this._pageMatches[pageIndex] = [];
                const matchesLength = this._pageMatchesLength[pageIndex] = [];
                if (!query) {
                  return;
                }
                const diffs = this._pageDiffs[pageIndex];
                let match;
                while ((match = query.exec(pageContent)) !== null) {
                  if (entireWord && !__privateMethod(this, _isEntireWord, isEntireWord_fn).call(this, pageContent, match.index, match[0].length)) {
                    continue;
                  }
                  const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length);
                  if (matchLen) {
                    matches.push(matchPos);
                    matchesLength.push(matchLen);
                  }
                }
              };
              _convertToRegExpString = new WeakSet();
              convertToRegExpString_fn = function(query, hasDiacritics) {
                const {
                  matchDiacritics
                } = __privateGet(this, _state);
                let isUnicode = false;
                query = query.replaceAll(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) => {
                  if (p1) {
                    return `[ ]*\\${p1}[ ]*`;
                  }
                  if (p2) {
                    return `[ ]*${p2}[ ]*`;
                  }
                  if (p3) {
                    return "[ ]+";
                  }
                  if (matchDiacritics) {
                    return p4 || p5;
                  }
                  if (p4) {
                    return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : "";
                  }
                  if (hasDiacritics) {
                    isUnicode = true;
                    return `${p5}\\p{M}*`;
                  }
                  return p5;
                });
                const trailingSpaces = "[ ]*";
                if (query.endsWith(trailingSpaces)) {
                  query = query.slice(0, query.length - trailingSpaces.length);
                }
                if (matchDiacritics) {
                  if (hasDiacritics) {
                    DIACRITICS_EXCEPTION_STR || (DIACRITICS_EXCEPTION_STR = String.fromCharCode(...DIACRITICS_EXCEPTION));
                    isUnicode = true;
                    query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\p{M}]|$)`;
                  }
                }
                return [isUnicode, query];
              };
              _calculateMatch = new WeakSet();
              calculateMatch_fn = function(pageIndex) {
                let query = __privateGet(this, _query, query_get);
                if (query.length === 0) {
                  return;
                }
                const {
                  caseSensitive,
                  entireWord
                } = __privateGet(this, _state);
                const pageContent = this._pageContents[pageIndex];
                const hasDiacritics = this._hasDiacritics[pageIndex];
                let isUnicode = false;
                if (typeof query === "string") {
                  [isUnicode, query] = __privateMethod(this, _convertToRegExpString, convertToRegExpString_fn).call(this, query, hasDiacritics);
                } else {
                  query = query.sort().reverse().map((q) => {
                    const [isUnicodePart, queryPart] = __privateMethod(this, _convertToRegExpString, convertToRegExpString_fn).call(this, q, hasDiacritics);
                    isUnicode || (isUnicode = isUnicodePart);
                    return `(${queryPart})`;
                  }).join("|");
                }
                const flags = `g${isUnicode ? "u" : ""}${caseSensitive ? "" : "i"}`;
                query = query ? new RegExp(query, flags) : null;
                __privateMethod(this, _calculateRegExpMatch, calculateRegExpMatch_fn).call(this, query, entireWord, pageIndex, pageContent);
                if (__privateGet(this, _state).highlightAll) {
                  __privateMethod(this, _updatePage, updatePage_fn).call(this, pageIndex);
                }
                if (this._resumePageIdx === pageIndex) {
                  this._resumePageIdx = null;
                  __privateMethod(this, _nextPageMatch, nextPageMatch_fn).call(this);
                }
                const pageMatchesCount = this._pageMatches[pageIndex].length;
                this._matchesCountTotal += pageMatchesCount;
                if (__privateGet(this, _updateMatchesCountOnProgress)) {
                  if (pageMatchesCount > 0) {
                    __privateMethod(this, _updateUIResultsCount, updateUIResultsCount_fn).call(this);
                  }
                } else if (++__privateWrapper(this, _visitedPagesCount)._ === this._linkService.pagesCount) {
                  __privateMethod(this, _updateUIResultsCount, updateUIResultsCount_fn).call(this);
                }
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                if (this._extractTextPromises.length > 0) {
                  return;
                }
                let promise = Promise.resolve();
                const textOptions = {
                  disableNormalization: true
                };
                for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
                  const extractTextCapability = new _pdfjsLib.PromiseCapability();
                  this._extractTextPromises[i] = extractTextCapability.promise;
                  promise = promise.then(() => {
                    return this._pdfDocument.getPage(i + 1).then((pdfPage) => {
                      return pdfPage.getTextContent(textOptions);
                    }).then((textContent) => {
                      const strBuf = [];
                      for (const textItem of textContent.items) {
                        strBuf.push(textItem.str);
                        if (textItem.hasEOL) {
                          strBuf.push("\n");
                        }
                      }
                      [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(strBuf.join(""));
                      extractTextCapability.resolve();
                    }, (reason) => {
                      console.error(`Unable to get text content for page ${i + 1}`, reason);
                      this._pageContents[i] = "";
                      this._pageDiffs[i] = null;
                      this._hasDiacritics[i] = false;
                      extractTextCapability.resolve();
                    });
                  });
                }
              };
              _updatePage = new WeakSet();
              updatePage_fn = function(index) {
                if (this._scrollMatches && this._selected.pageIdx === index) {
                  this._linkService.page = index + 1;
                }
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: index
                });
              };
              _updateAllPages = new WeakSet();
              updateAllPages_fn = function() {
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: -1
                });
              };
              _nextMatch = new WeakSet();
              nextMatch_fn = function() {
                const previous = __privateGet(this, _state).findPrevious;
                const currentPageIndex = this._linkService.page - 1;
                const numPages = this._linkService.pagesCount;
                this._highlightMatches = true;
                if (this._dirtyMatch) {
                  this._dirtyMatch = false;
                  this._selected.pageIdx = this._selected.matchIdx = -1;
                  this._offset.pageIdx = currentPageIndex;
                  this._offset.matchIdx = null;
                  this._offset.wrapped = false;
                  this._resumePageIdx = null;
                  this._pageMatches.length = 0;
                  this._pageMatchesLength.length = 0;
                  __privateSet(this, _visitedPagesCount, 0);
                  this._matchesCountTotal = 0;
                  __privateMethod(this, _updateAllPages, updateAllPages_fn).call(this);
                  for (let i = 0; i < numPages; i++) {
                    if (this._pendingFindMatches.has(i)) {
                      continue;
                    }
                    this._pendingFindMatches.add(i);
                    this._extractTextPromises[i].then(() => {
                      this._pendingFindMatches.delete(i);
                      __privateMethod(this, _calculateMatch, calculateMatch_fn).call(this, i);
                    });
                  }
                }
                const query = __privateGet(this, _query, query_get);
                if (query.length === 0) {
                  __privateMethod(this, _updateUIState, updateUIState_fn).call(this, FindState.FOUND);
                  return;
                }
                if (this._resumePageIdx) {
                  return;
                }
                const offset = this._offset;
                this._pagesToSearch = numPages;
                if (offset.matchIdx !== null) {
                  const numPageMatches = this._pageMatches[offset.pageIdx].length;
                  if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
                    offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
                    __privateMethod(this, _updateMatch, updateMatch_fn).call(this, true);
                    return;
                  }
                  __privateMethod(this, _advanceOffsetPage, advanceOffsetPage_fn).call(this, previous);
                }
                __privateMethod(this, _nextPageMatch, nextPageMatch_fn).call(this);
              };
              _matchesReady = new WeakSet();
              matchesReady_fn = function(matches) {
                const offset = this._offset;
                const numMatches = matches.length;
                const previous = __privateGet(this, _state).findPrevious;
                if (numMatches) {
                  offset.matchIdx = previous ? numMatches - 1 : 0;
                  __privateMethod(this, _updateMatch, updateMatch_fn).call(this, true);
                  return true;
                }
                __privateMethod(this, _advanceOffsetPage, advanceOffsetPage_fn).call(this, previous);
                if (offset.wrapped) {
                  offset.matchIdx = null;
                  if (this._pagesToSearch < 0) {
                    __privateMethod(this, _updateMatch, updateMatch_fn).call(this, false);
                    return true;
                  }
                }
                return false;
              };
              _nextPageMatch = new WeakSet();
              nextPageMatch_fn = function() {
                if (this._resumePageIdx !== null) {
                  console.error("There can only be one pending page.");
                }
                let matches = null;
                do {
                  const pageIdx = this._offset.pageIdx;
                  matches = this._pageMatches[pageIdx];
                  if (!matches) {
                    this._resumePageIdx = pageIdx;
                    break;
                  }
                } while (!__privateMethod(this, _matchesReady, matchesReady_fn).call(this, matches));
              };
              _advanceOffsetPage = new WeakSet();
              advanceOffsetPage_fn = function(previous) {
                const offset = this._offset;
                const numPages = this._linkService.pagesCount;
                offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
                offset.matchIdx = null;
                this._pagesToSearch--;
                if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
                  offset.pageIdx = previous ? numPages - 1 : 0;
                  offset.wrapped = true;
                }
              };
              _updateMatch = new WeakSet();
              updateMatch_fn = function(found = false) {
                let state = FindState.NOT_FOUND;
                const wrapped = this._offset.wrapped;
                this._offset.wrapped = false;
                if (found) {
                  const previousPage = this._selected.pageIdx;
                  this._selected.pageIdx = this._offset.pageIdx;
                  this._selected.matchIdx = this._offset.matchIdx;
                  state = wrapped ? FindState.WRAPPED : FindState.FOUND;
                  if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                    __privateMethod(this, _updatePage, updatePage_fn).call(this, previousPage);
                  }
                }
                __privateMethod(this, _updateUIState, updateUIState_fn).call(this, state, __privateGet(this, _state).findPrevious);
                if (this._selected.pageIdx !== -1) {
                  this._scrollMatches = true;
                  __privateMethod(this, _updatePage, updatePage_fn).call(this, this._selected.pageIdx);
                }
              };
              _onFindBarClose = new WeakSet();
              onFindBarClose_fn = function(evt) {
                const pdfDocument = this._pdfDocument;
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (this._resumePageIdx) {
                    this._resumePageIdx = null;
                    this._dirtyMatch = true;
                  }
                  __privateMethod(this, _updateUIState, updateUIState_fn).call(this, FindState.FOUND);
                  this._highlightMatches = false;
                  __privateMethod(this, _updateAllPages, updateAllPages_fn).call(this);
                });
              };
              _requestMatchesCount = new WeakSet();
              requestMatchesCount_fn = function() {
                var _a;
                const {
                  pageIdx,
                  matchIdx
                } = this._selected;
                let current = 0, total = this._matchesCountTotal;
                if (matchIdx !== -1) {
                  for (let i = 0; i < pageIdx; i++) {
                    current += ((_a = this._pageMatches[i]) == null ? void 0 : _a.length) || 0;
                  }
                  current += matchIdx + 1;
                }
                if (current < 1 || current > total) {
                  current = total = 0;
                }
                return {
                  current,
                  total
                };
              };
              _updateUIResultsCount = new WeakSet();
              updateUIResultsCount_fn = function() {
                this._eventBus.dispatch("updatefindmatchescount", {
                  source: this,
                  matchesCount: __privateMethod(this, _requestMatchesCount, requestMatchesCount_fn).call(this)
                });
              };
              _updateUIState = new WeakSet();
              updateUIState_fn = function(state, previous = false) {
                var _a;
                if (!__privateGet(this, _updateMatchesCountOnProgress) && (__privateGet(this, _visitedPagesCount) !== this._linkService.pagesCount || state === FindState.PENDING)) {
                  return;
                }
                this._eventBus.dispatch("updatefindcontrolstate", {
                  source: this,
                  state,
                  previous,
                  matchesCount: __privateMethod(this, _requestMatchesCount, requestMatchesCount_fn).call(this),
                  rawQuery: ((_a = __privateGet(this, _state)) == null ? void 0 : _a.query) ?? null
                });
              };
              exports2.PDFFindController = PDFFindController;
            },
            /* 2 */
            /***/
            (__unused_webpack_module, exports2) => {
              var _classList, _disableAutoFetchTimeout, _percent, _style, _visible;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.animationStarted = exports2.VERTICAL_PADDING = exports2.UNKNOWN_SCALE = exports2.TextLayerMode = exports2.SpreadMode = exports2.SidebarView = exports2.ScrollMode = exports2.SCROLLBAR_PADDING = exports2.RenderingStates = exports2.ProgressBar = exports2.PresentationModeState = exports2.OutputScale = exports2.MIN_SCALE = exports2.MAX_SCALE = exports2.MAX_AUTO_SCALE = exports2.DEFAULT_SCALE_VALUE = exports2.DEFAULT_SCALE_DELTA = exports2.DEFAULT_SCALE = exports2.CursorTool = exports2.AutoPrintRegExp = void 0;
              exports2.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
              exports2.apiPageModeToSidebarView = apiPageModeToSidebarView;
              exports2.approximateFraction = approximateFraction;
              exports2.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
              exports2.binarySearchFirstItem = binarySearchFirstItem;
              exports2.docStyle = void 0;
              exports2.getActiveOrFocusedElement = getActiveOrFocusedElement;
              exports2.getPageSizeInches = getPageSizeInches;
              exports2.getVisibleElements = getVisibleElements;
              exports2.isPortraitOrientation = isPortraitOrientation;
              exports2.isValidRotation = isValidRotation;
              exports2.isValidScrollMode = isValidScrollMode;
              exports2.isValidSpreadMode = isValidSpreadMode;
              exports2.noContextMenuHandler = noContextMenuHandler;
              exports2.normalizeWheelEventDelta = normalizeWheelEventDelta;
              exports2.normalizeWheelEventDirection = normalizeWheelEventDirection;
              exports2.parseQueryString = parseQueryString;
              exports2.removeNullCharacters = removeNullCharacters;
              exports2.roundToDivide = roundToDivide;
              exports2.scrollIntoView = scrollIntoView;
              exports2.toggleCheckedBtn = toggleCheckedBtn;
              exports2.toggleExpandedBtn = toggleExpandedBtn;
              exports2.watchScroll = watchScroll;
              const DEFAULT_SCALE_VALUE = "auto";
              exports2.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
              const DEFAULT_SCALE = 1;
              exports2.DEFAULT_SCALE = DEFAULT_SCALE;
              const DEFAULT_SCALE_DELTA = 1.1;
              exports2.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA;
              const MIN_SCALE = 0.1;
              exports2.MIN_SCALE = MIN_SCALE;
              const MAX_SCALE = 10;
              exports2.MAX_SCALE = MAX_SCALE;
              const UNKNOWN_SCALE = 0;
              exports2.UNKNOWN_SCALE = UNKNOWN_SCALE;
              const MAX_AUTO_SCALE = 1.25;
              exports2.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
              const SCROLLBAR_PADDING = 40;
              exports2.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
              const VERTICAL_PADDING = 5;
              exports2.VERTICAL_PADDING = VERTICAL_PADDING;
              const RenderingStates = {
                INITIAL: 0,
                RUNNING: 1,
                PAUSED: 2,
                FINISHED: 3
              };
              exports2.RenderingStates = RenderingStates;
              const PresentationModeState = {
                UNKNOWN: 0,
                NORMAL: 1,
                CHANGING: 2,
                FULLSCREEN: 3
              };
              exports2.PresentationModeState = PresentationModeState;
              const SidebarView = {
                UNKNOWN: -1,
                NONE: 0,
                THUMBS: 1,
                OUTLINE: 2,
                ATTACHMENTS: 3,
                LAYERS: 4
              };
              exports2.SidebarView = SidebarView;
              const TextLayerMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_PERMISSIONS: 2
              };
              exports2.TextLayerMode = TextLayerMode;
              const ScrollMode = {
                UNKNOWN: -1,
                VERTICAL: 0,
                HORIZONTAL: 1,
                WRAPPED: 2,
                PAGE: 3
              };
              exports2.ScrollMode = ScrollMode;
              const SpreadMode = {
                UNKNOWN: -1,
                NONE: 0,
                ODD: 1,
                EVEN: 2
              };
              exports2.SpreadMode = SpreadMode;
              const CursorTool = {
                SELECT: 0,
                HAND: 1,
                ZOOM: 2
              };
              exports2.CursorTool = CursorTool;
              const AutoPrintRegExp = /\bprint\s*\(/;
              exports2.AutoPrintRegExp = AutoPrintRegExp;
              class OutputScale {
                constructor() {
                  const pixelRatio = window.devicePixelRatio || 1;
                  this.sx = pixelRatio;
                  this.sy = pixelRatio;
                }
                get scaled() {
                  return this.sx !== 1 || this.sy !== 1;
                }
              }
              exports2.OutputScale = OutputScale;
              function scrollIntoView(element, spot, scrollMatches = false) {
                let parent = element.offsetParent;
                if (!parent) {
                  console.error("offsetParent is not set -- cannot scroll");
                  return;
                }
                let offsetY = element.offsetTop + element.clientTop;
                let offsetX = element.offsetLeft + element.clientLeft;
                while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
                  offsetY += parent.offsetTop;
                  offsetX += parent.offsetLeft;
                  parent = parent.offsetParent;
                  if (!parent) {
                    return;
                  }
                }
                if (spot) {
                  if (spot.top !== void 0) {
                    offsetY += spot.top;
                  }
                  if (spot.left !== void 0) {
                    offsetX += spot.left;
                    parent.scrollLeft = offsetX;
                  }
                }
                parent.scrollTop = offsetY;
              }
              function watchScroll(viewAreaElement, callback) {
                const debounceScroll = function(evt) {
                  if (rAF) {
                    return;
                  }
                  rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
                    rAF = null;
                    const currentX = viewAreaElement.scrollLeft;
                    const lastX = state.lastX;
                    if (currentX !== lastX) {
                      state.right = currentX > lastX;
                    }
                    state.lastX = currentX;
                    const currentY = viewAreaElement.scrollTop;
                    const lastY = state.lastY;
                    if (currentY !== lastY) {
                      state.down = currentY > lastY;
                    }
                    state.lastY = currentY;
                    callback(state);
                  });
                };
                const state = {
                  right: true,
                  down: true,
                  lastX: viewAreaElement.scrollLeft,
                  lastY: viewAreaElement.scrollTop,
                  _eventHandler: debounceScroll
                };
                let rAF = null;
                viewAreaElement.addEventListener("scroll", debounceScroll, true);
                return state;
              }
              function parseQueryString(query) {
                const params = /* @__PURE__ */ new Map();
                for (const [key, value] of new URLSearchParams(query)) {
                  params.set(key.toLowerCase(), value);
                }
                return params;
              }
              const InvisibleCharactersRegExp = /[\x01-\x1F]/g;
              function removeNullCharacters(str, replaceInvisible = false) {
                if (typeof str !== "string") {
                  console.error(`The argument must be a string.`);
                  return str;
                }
                if (replaceInvisible) {
                  str = str.replaceAll(InvisibleCharactersRegExp, " ");
                }
                return str.replaceAll("\0", "");
              }
              function binarySearchFirstItem(items, condition, start = 0) {
                let minIndex = start;
                let maxIndex = items.length - 1;
                if (maxIndex < 0 || !condition(items[maxIndex])) {
                  return items.length;
                }
                if (condition(items[minIndex])) {
                  return minIndex;
                }
                while (minIndex < maxIndex) {
                  const currentIndex = minIndex + maxIndex >> 1;
                  const currentItem = items[currentIndex];
                  if (condition(currentItem)) {
                    maxIndex = currentIndex;
                  } else {
                    minIndex = currentIndex + 1;
                  }
                }
                return minIndex;
              }
              function approximateFraction(x) {
                if (Math.floor(x) === x) {
                  return [x, 1];
                }
                const xinv = 1 / x;
                const limit = 8;
                if (xinv > limit) {
                  return [1, limit];
                } else if (Math.floor(xinv) === xinv) {
                  return [1, xinv];
                }
                const x_ = x > 1 ? xinv : x;
                let a = 0, b = 1, c = 1, d = 1;
                while (true) {
                  const p = a + c, q = b + d;
                  if (q > limit) {
                    break;
                  }
                  if (x_ <= p / q) {
                    c = p;
                    d = q;
                  } else {
                    a = p;
                    b = q;
                  }
                }
                let result;
                if (x_ - a / b < c / d - x_) {
                  result = x_ === x ? [a, b] : [b, a];
                } else {
                  result = x_ === x ? [c, d] : [d, c];
                }
                return result;
              }
              function roundToDivide(x, div) {
                const r = x % div;
                return r === 0 ? x : Math.round(x - r + div);
              }
              function getPageSizeInches({
                view,
                userUnit,
                rotate
              }) {
                const [x1, y1, x2, y2] = view;
                const changeOrientation = rotate % 180 !== 0;
                const width = (x2 - x1) / 72 * userUnit;
                const height = (y2 - y1) / 72 * userUnit;
                return {
                  width: changeOrientation ? height : width,
                  height: changeOrientation ? width : height
                };
              }
              function backtrackBeforeAllVisibleElements(index, views, top) {
                if (index < 2) {
                  return index;
                }
                let elt = views[index].div;
                let pageTop = elt.offsetTop + elt.clientTop;
                if (pageTop >= top) {
                  elt = views[index - 1].div;
                  pageTop = elt.offsetTop + elt.clientTop;
                }
                for (let i = index - 2; i >= 0; --i) {
                  elt = views[i].div;
                  if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
                    break;
                  }
                  index = i;
                }
                return index;
              }
              function getVisibleElements({
                scrollEl,
                views,
                sortByVisibility = false,
                horizontal = false,
                rtl = false
              }) {
                const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
                const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
                function isElementBottomAfterViewTop(view) {
                  const element = view.div;
                  const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
                  return elementBottom > top;
                }
                function isElementNextAfterViewHorizontally(view) {
                  const element = view.div;
                  const elementLeft = element.offsetLeft + element.clientLeft;
                  const elementRight = elementLeft + element.clientWidth;
                  return rtl ? elementLeft < right : elementRight > left;
                }
                const visible = [], ids = /* @__PURE__ */ new Set(), numViews = views.length;
                let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);
                if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
                  firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
                }
                let lastEdge = horizontal ? right : -1;
                for (let i = firstVisibleElementInd; i < numViews; i++) {
                  const view = views[i], element = view.div;
                  const currentWidth = element.offsetLeft + element.clientLeft;
                  const currentHeight = element.offsetTop + element.clientTop;
                  const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
                  const viewRight = currentWidth + viewWidth;
                  const viewBottom = currentHeight + viewHeight;
                  if (lastEdge === -1) {
                    if (viewBottom >= bottom) {
                      lastEdge = viewBottom;
                    }
                  } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
                    break;
                  }
                  if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
                    continue;
                  }
                  const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
                  const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
                  const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
                  const percent = fractionHeight * fractionWidth * 100 | 0;
                  visible.push({
                    id: view.id,
                    x: currentWidth,
                    y: currentHeight,
                    view,
                    percent,
                    widthPercent: fractionWidth * 100 | 0
                  });
                  ids.add(view.id);
                }
                const first = visible[0], last = visible.at(-1);
                if (sortByVisibility) {
                  visible.sort(function(a, b) {
                    const pc = a.percent - b.percent;
                    if (Math.abs(pc) > 1e-3) {
                      return -pc;
                    }
                    return a.id - b.id;
                  });
                }
                return {
                  first,
                  last,
                  views: visible,
                  ids
                };
              }
              function noContextMenuHandler(evt) {
                evt.preventDefault();
              }
              function normalizeWheelEventDirection(evt) {
                let delta = Math.hypot(evt.deltaX, evt.deltaY);
                const angle = Math.atan2(evt.deltaY, evt.deltaX);
                if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
                  delta = -delta;
                }
                return delta;
              }
              function normalizeWheelEventDelta(evt) {
                const deltaMode = evt.deltaMode;
                let delta = normalizeWheelEventDirection(evt);
                const MOUSE_PIXELS_PER_LINE = 30;
                const MOUSE_LINES_PER_PAGE = 30;
                if (deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                  delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
                } else if (deltaMode === WheelEvent.DOM_DELTA_LINE) {
                  delta /= MOUSE_LINES_PER_PAGE;
                }
                return delta;
              }
              function isValidRotation(angle) {
                return Number.isInteger(angle) && angle % 90 === 0;
              }
              function isValidScrollMode(mode) {
                return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
              }
              function isValidSpreadMode(mode) {
                return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
              }
              function isPortraitOrientation(size) {
                return size.width <= size.height;
              }
              const animationStarted = new Promise(function(resolve) {
                window.requestAnimationFrame(resolve);
              });
              exports2.animationStarted = animationStarted;
              const docStyle = document.documentElement.style;
              exports2.docStyle = docStyle;
              function clamp(v, min, max) {
                return Math.min(Math.max(v, min), max);
              }
              class ProgressBar {
                constructor(bar) {
                  __privateAdd(this, _classList, null);
                  __privateAdd(this, _disableAutoFetchTimeout, null);
                  __privateAdd(this, _percent, 0);
                  __privateAdd(this, _style, null);
                  __privateAdd(this, _visible, true);
                  __privateSet(this, _classList, bar.classList);
                  __privateSet(this, _style, bar.style);
                }
                get percent() {
                  return __privateGet(this, _percent);
                }
                set percent(val) {
                  __privateSet(this, _percent, clamp(val, 0, 100));
                  if (isNaN(val)) {
                    __privateGet(this, _classList).add("indeterminate");
                    return;
                  }
                  __privateGet(this, _classList).remove("indeterminate");
                  __privateGet(this, _style).setProperty("--progressBar-percent", `${__privateGet(this, _percent)}%`);
                }
                setWidth(viewer) {
                  if (!viewer) {
                    return;
                  }
                  const container = viewer.parentNode;
                  const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
                  if (scrollbarWidth > 0) {
                    __privateGet(this, _style).setProperty("--progressBar-end-offset", `${scrollbarWidth}px`);
                  }
                }
                setDisableAutoFetch(delay = 5e3) {
                  if (isNaN(__privateGet(this, _percent))) {
                    return;
                  }
                  if (__privateGet(this, _disableAutoFetchTimeout)) {
                    clearTimeout(__privateGet(this, _disableAutoFetchTimeout));
                  }
                  this.show();
                  __privateSet(this, _disableAutoFetchTimeout, setTimeout(() => {
                    __privateSet(this, _disableAutoFetchTimeout, null);
                    this.hide();
                  }, delay));
                }
                hide() {
                  if (!__privateGet(this, _visible)) {
                    return;
                  }
                  __privateSet(this, _visible, false);
                  __privateGet(this, _classList).add("hidden");
                }
                show() {
                  if (__privateGet(this, _visible)) {
                    return;
                  }
                  __privateSet(this, _visible, true);
                  __privateGet(this, _classList).remove("hidden");
                }
              }
              _classList = new WeakMap();
              _disableAutoFetchTimeout = new WeakMap();
              _percent = new WeakMap();
              _style = new WeakMap();
              _visible = new WeakMap();
              exports2.ProgressBar = ProgressBar;
              function getActiveOrFocusedElement() {
                let curRoot = document;
                let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
                while (curActiveOrFocused == null ? void 0 : curActiveOrFocused.shadowRoot) {
                  curRoot = curActiveOrFocused.shadowRoot;
                  curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
                }
                return curActiveOrFocused;
              }
              function apiPageLayoutToViewerModes(layout) {
                let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE;
                switch (layout) {
                  case "SinglePage":
                    scrollMode = ScrollMode.PAGE;
                    break;
                  case "OneColumn":
                    break;
                  case "TwoPageLeft":
                    scrollMode = ScrollMode.PAGE;
                  case "TwoColumnLeft":
                    spreadMode = SpreadMode.ODD;
                    break;
                  case "TwoPageRight":
                    scrollMode = ScrollMode.PAGE;
                  case "TwoColumnRight":
                    spreadMode = SpreadMode.EVEN;
                    break;
                }
                return {
                  scrollMode,
                  spreadMode
                };
              }
              function apiPageModeToSidebarView(mode) {
                switch (mode) {
                  case "UseNone":
                    return SidebarView.NONE;
                  case "UseThumbs":
                    return SidebarView.THUMBS;
                  case "UseOutlines":
                    return SidebarView.OUTLINE;
                  case "UseAttachments":
                    return SidebarView.ATTACHMENTS;
                  case "UseOC":
                    return SidebarView.LAYERS;
                }
                return SidebarView.NONE;
              }
              function toggleCheckedBtn(button, toggle, view = null) {
                button.classList.toggle("toggled", toggle);
                button.setAttribute("aria-checked", toggle);
                view == null ? void 0 : view.classList.toggle("hidden", !toggle);
              }
              function toggleExpandedBtn(button, toggle, view = null) {
                button.classList.toggle("toggled", toggle);
                button.setAttribute("aria-expanded", toggle);
                view == null ? void 0 : view.classList.toggle("hidden", !toggle);
              }
            },
            /* 3 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CharacterType = void 0;
              exports2.getCharacterType = getCharacterType;
              exports2.getNormalizeWithNFKC = getNormalizeWithNFKC;
              const CharacterType = {
                SPACE: 0,
                ALPHA_LETTER: 1,
                PUNCT: 2,
                HAN_LETTER: 3,
                KATAKANA_LETTER: 4,
                HIRAGANA_LETTER: 5,
                HALFWIDTH_KATAKANA_LETTER: 6,
                THAI_LETTER: 7
              };
              exports2.CharacterType = CharacterType;
              function isAlphabeticalScript(charCode) {
                return charCode < 11904;
              }
              function isAscii(charCode) {
                return (charCode & 65408) === 0;
              }
              function isAsciiAlpha(charCode) {
                return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
              }
              function isAsciiDigit(charCode) {
                return charCode >= 48 && charCode <= 57;
              }
              function isAsciiSpace(charCode) {
                return charCode === 32 || charCode === 9 || charCode === 13 || charCode === 10;
              }
              function isHan(charCode) {
                return charCode >= 13312 && charCode <= 40959 || charCode >= 63744 && charCode <= 64255;
              }
              function isKatakana(charCode) {
                return charCode >= 12448 && charCode <= 12543;
              }
              function isHiragana(charCode) {
                return charCode >= 12352 && charCode <= 12447;
              }
              function isHalfwidthKatakana(charCode) {
                return charCode >= 65376 && charCode <= 65439;
              }
              function isThai(charCode) {
                return (charCode & 65408) === 3584;
              }
              function getCharacterType(charCode) {
                if (isAlphabeticalScript(charCode)) {
                  if (isAscii(charCode)) {
                    if (isAsciiSpace(charCode)) {
                      return CharacterType.SPACE;
                    } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 95) {
                      return CharacterType.ALPHA_LETTER;
                    }
                    return CharacterType.PUNCT;
                  } else if (isThai(charCode)) {
                    return CharacterType.THAI_LETTER;
                  } else if (charCode === 160) {
                    return CharacterType.SPACE;
                  }
                  return CharacterType.ALPHA_LETTER;
                }
                if (isHan(charCode)) {
                  return CharacterType.HAN_LETTER;
                } else if (isKatakana(charCode)) {
                  return CharacterType.KATAKANA_LETTER;
                } else if (isHiragana(charCode)) {
                  return CharacterType.HIRAGANA_LETTER;
                } else if (isHalfwidthKatakana(charCode)) {
                  return CharacterType.HALFWIDTH_KATAKANA_LETTER;
                }
                return CharacterType.ALPHA_LETTER;
              }
              let NormalizeWithNFKC;
              function getNormalizeWithNFKC() {
                NormalizeWithNFKC || (NormalizeWithNFKC = ` ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦`);
                return NormalizeWithNFKC;
              }
            },
            /* 4 */
            /***/
            (module2) => {
              module2.exports = globalThis.pdfjsLib;
            },
            /* 5 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _pagesRefCache, _goToDestinationHelper, goToDestinationHelper_fn, _isValidExplicitDestination, isValidExplicitDestination_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SimpleLinkService = exports2.PDFLinkService = exports2.LinkTarget = void 0;
              var _ui_utils = __w_pdfjs_require__2(2);
              const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
              const LinkTarget = {
                NONE: 0,
                SELF: 1,
                BLANK: 2,
                PARENT: 3,
                TOP: 4
              };
              exports2.LinkTarget = LinkTarget;
              function addLinkAttributes(link, {
                url,
                target,
                rel,
                enabled = true
              } = {}) {
                if (!url || typeof url !== "string") {
                  throw new Error('A valid "url" parameter must provided.');
                }
                const urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url);
                if (enabled) {
                  link.href = link.title = urlNullRemoved;
                } else {
                  link.href = "";
                  link.title = `Disabled: ${urlNullRemoved}`;
                  link.onclick = () => {
                    return false;
                  };
                }
                let targetStr = "";
                switch (target) {
                  case LinkTarget.NONE:
                    break;
                  case LinkTarget.SELF:
                    targetStr = "_self";
                    break;
                  case LinkTarget.BLANK:
                    targetStr = "_blank";
                    break;
                  case LinkTarget.PARENT:
                    targetStr = "_parent";
                    break;
                  case LinkTarget.TOP:
                    targetStr = "_top";
                    break;
                }
                link.target = targetStr;
                link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
              }
              const _PDFLinkService = class _PDFLinkService {
                constructor({
                  eventBus,
                  externalLinkTarget = null,
                  externalLinkRel = null,
                  ignoreDestinationZoom = false
                } = {}) {
                  __privateAdd(this, _goToDestinationHelper);
                  __privateAdd(this, _pagesRefCache, /* @__PURE__ */ new Map());
                  this.eventBus = eventBus;
                  this.externalLinkTarget = externalLinkTarget;
                  this.externalLinkRel = externalLinkRel;
                  this.externalLinkEnabled = true;
                  this._ignoreDestinationZoom = ignoreDestinationZoom;
                  this.baseUrl = null;
                  this.pdfDocument = null;
                  this.pdfViewer = null;
                  this.pdfHistory = null;
                }
                setDocument(pdfDocument, baseUrl = null) {
                  this.baseUrl = baseUrl;
                  this.pdfDocument = pdfDocument;
                  __privateGet(this, _pagesRefCache).clear();
                }
                setViewer(pdfViewer) {
                  this.pdfViewer = pdfViewer;
                }
                setHistory(pdfHistory) {
                  this.pdfHistory = pdfHistory;
                }
                get pagesCount() {
                  return this.pdfDocument ? this.pdfDocument.numPages : 0;
                }
                get page() {
                  return this.pdfViewer.currentPageNumber;
                }
                set page(value) {
                  this.pdfViewer.currentPageNumber = value;
                }
                get rotation() {
                  return this.pdfViewer.pagesRotation;
                }
                set rotation(value) {
                  this.pdfViewer.pagesRotation = value;
                }
                get isInPresentationMode() {
                  return this.pdfViewer.isInPresentationMode;
                }
                async goToDestination(dest) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let namedDest, explicitDest;
                  if (typeof dest === "string") {
                    namedDest = dest;
                    explicitDest = await this.pdfDocument.getDestination(dest);
                  } else {
                    namedDest = null;
                    explicitDest = await dest;
                  }
                  if (!Array.isArray(explicitDest)) {
                    console.error(`PDFLinkService.goToDestination: "${explicitDest}" is not a valid destination array, for dest="${dest}".`);
                    return;
                  }
                  __privateMethod(this, _goToDestinationHelper, goToDestinationHelper_fn).call(this, dest, namedDest, explicitDest);
                }
                goToPage(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;
                  if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                    console.error(`PDFLinkService.goToPage: "${val}" is not a valid page.`);
                    return;
                  }
                  if (this.pdfHistory) {
                    this.pdfHistory.pushCurrentPosition();
                    this.pdfHistory.pushPage(pageNumber);
                  }
                  this.pdfViewer.scrollPageIntoView({
                    pageNumber
                  });
                }
                addLinkAttributes(link, url, newWindow = false) {
                  addLinkAttributes(link, {
                    url,
                    target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,
                    rel: this.externalLinkRel,
                    enabled: this.externalLinkEnabled
                  });
                }
                getDestinationHash(dest) {
                  if (typeof dest === "string") {
                    if (dest.length > 0) {
                      return this.getAnchorUrl("#" + escape(dest));
                    }
                  } else if (Array.isArray(dest)) {
                    const str = JSON.stringify(dest);
                    if (str.length > 0) {
                      return this.getAnchorUrl("#" + escape(str));
                    }
                  }
                  return this.getAnchorUrl("");
                }
                getAnchorUrl(anchor) {
                  return this.baseUrl ? this.baseUrl + anchor : anchor;
                }
                setHash(hash) {
                  var _a;
                  if (!this.pdfDocument) {
                    return;
                  }
                  let pageNumber, dest;
                  if (hash.includes("=")) {
                    const params = (0, _ui_utils.parseQueryString)(hash);
                    if (params.has("search")) {
                      const query = params.get("search").replaceAll('"', ""), phrase = params.get("phrase") === "true";
                      this.eventBus.dispatch("findfromurlhash", {
                        source: this,
                        query: phrase ? query : query.match(/\S+/g)
                      });
                    }
                    if (params.has("page")) {
                      pageNumber = params.get("page") | 0 || 1;
                    }
                    if (params.has("zoom")) {
                      const zoomArgs = params.get("zoom").split(",");
                      const zoomArg = zoomArgs[0];
                      const zoomArgNumber = parseFloat(zoomArg);
                      if (!zoomArg.includes("Fit")) {
                        dest = [null, {
                          name: "XYZ"
                        }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
                      } else if (zoomArg === "Fit" || zoomArg === "FitB") {
                        dest = [null, {
                          name: zoomArg
                        }];
                      } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                        dest = [null, {
                          name: zoomArg
                        }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                      } else if (zoomArg === "FitR") {
                        if (zoomArgs.length !== 5) {
                          console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                        } else {
                          dest = [null, {
                            name: zoomArg
                          }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                        }
                      } else {
                        console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
                      }
                    }
                    if (dest) {
                      this.pdfViewer.scrollPageIntoView({
                        pageNumber: pageNumber || this.page,
                        destArray: dest,
                        allowNegativeOffset: true
                      });
                    } else if (pageNumber) {
                      this.page = pageNumber;
                    }
                    if (params.has("pagemode")) {
                      this.eventBus.dispatch("pagemode", {
                        source: this,
                        mode: params.get("pagemode")
                      });
                    }
                    if (params.has("nameddest")) {
                      this.goToDestination(params.get("nameddest"));
                    }
                  } else {
                    dest = unescape(hash);
                    try {
                      dest = JSON.parse(dest);
                      if (!Array.isArray(dest)) {
                        dest = dest.toString();
                      }
                    } catch {
                    }
                    if (typeof dest === "string" || __privateMethod(_a = _PDFLinkService, _isValidExplicitDestination, isValidExplicitDestination_fn).call(_a, dest)) {
                      this.goToDestination(dest);
                      return;
                    }
                    console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
                  }
                }
                executeNamedAction(action) {
                  var _a, _b;
                  switch (action) {
                    case "GoBack":
                      (_a = this.pdfHistory) == null ? void 0 : _a.back();
                      break;
                    case "GoForward":
                      (_b = this.pdfHistory) == null ? void 0 : _b.forward();
                      break;
                    case "NextPage":
                      this.pdfViewer.nextPage();
                      break;
                    case "PrevPage":
                      this.pdfViewer.previousPage();
                      break;
                    case "LastPage":
                      this.page = this.pagesCount;
                      break;
                    case "FirstPage":
                      this.page = 1;
                      break;
                    default:
                      break;
                  }
                  this.eventBus.dispatch("namedaction", {
                    source: this,
                    action
                  });
                }
                async executeSetOCGState(action) {
                  const pdfDocument = this.pdfDocument;
                  const optionalContentConfig = await this.pdfViewer.optionalContentConfigPromise;
                  if (pdfDocument !== this.pdfDocument) {
                    return;
                  }
                  let operator;
                  for (const elem of action.state) {
                    switch (elem) {
                      case "ON":
                      case "OFF":
                      case "Toggle":
                        operator = elem;
                        continue;
                    }
                    switch (operator) {
                      case "ON":
                        optionalContentConfig.setVisibility(elem, true);
                        break;
                      case "OFF":
                        optionalContentConfig.setVisibility(elem, false);
                        break;
                      case "Toggle":
                        const group = optionalContentConfig.getGroup(elem);
                        if (group) {
                          optionalContentConfig.setVisibility(elem, !group.visible);
                        }
                        break;
                    }
                  }
                  this.pdfViewer.optionalContentConfigPromise = Promise.resolve(optionalContentConfig);
                }
                cachePageRef(pageNum, pageRef) {
                  if (!pageRef) {
                    return;
                  }
                  const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                  __privateGet(this, _pagesRefCache).set(refStr, pageNum);
                }
                _cachedPageNumber(pageRef) {
                  if (!pageRef) {
                    return null;
                  }
                  const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                  return __privateGet(this, _pagesRefCache).get(refStr) || null;
                }
              };
              _pagesRefCache = new WeakMap();
              _goToDestinationHelper = new WeakSet();
              goToDestinationHelper_fn = function(rawDest, namedDest = null, explicitDest) {
                const destRef = explicitDest[0];
                let pageNumber;
                if (typeof destRef === "object" && destRef !== null) {
                  pageNumber = this._cachedPageNumber(destRef);
                  if (!pageNumber) {
                    this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
                      this.cachePageRef(pageIndex + 1, destRef);
                      __privateMethod(this, _goToDestinationHelper, goToDestinationHelper_fn).call(this, rawDest, namedDest, explicitDest);
                    }).catch(() => {
                      console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not a valid page reference, for dest="${rawDest}".`);
                    });
                    return;
                  }
                } else if (Number.isInteger(destRef)) {
                  pageNumber = destRef + 1;
                } else {
                  console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not a valid destination reference, for dest="${rawDest}".`);
                  return;
                }
                if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
                  console.error(`PDFLinkService.#goToDestinationHelper: "${pageNumber}" is not a valid page number, for dest="${rawDest}".`);
                  return;
                }
                if (this.pdfHistory) {
                  this.pdfHistory.pushCurrentPosition();
                  this.pdfHistory.push({
                    namedDest,
                    explicitDest,
                    pageNumber
                  });
                }
                this.pdfViewer.scrollPageIntoView({
                  pageNumber,
                  destArray: explicitDest,
                  ignoreDestinationZoom: this._ignoreDestinationZoom
                });
              };
              _isValidExplicitDestination = new WeakSet();
              isValidExplicitDestination_fn = function(dest) {
                if (!Array.isArray(dest)) {
                  return false;
                }
                const destLength = dest.length;
                if (destLength < 2) {
                  return false;
                }
                const page = dest[0];
                if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
                  return false;
                }
                const zoom = dest[1];
                if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
                  return false;
                }
                let allowNull = true;
                switch (zoom.name) {
                  case "XYZ":
                    if (destLength !== 5) {
                      return false;
                    }
                    break;
                  case "Fit":
                  case "FitB":
                    return destLength === 2;
                  case "FitH":
                  case "FitBH":
                  case "FitV":
                  case "FitBV":
                    if (destLength !== 3) {
                      return false;
                    }
                    break;
                  case "FitR":
                    if (destLength !== 6) {
                      return false;
                    }
                    allowNull = false;
                    break;
                  default:
                    return false;
                }
                for (let i = 2; i < destLength; i++) {
                  const param = dest[i];
                  if (!(typeof param === "number" || allowNull && param === null)) {
                    return false;
                  }
                }
                return true;
              };
              __privateAdd(_PDFLinkService, _isValidExplicitDestination);
              let PDFLinkService = _PDFLinkService;
              exports2.PDFLinkService = PDFLinkService;
              class SimpleLinkService {
                constructor() {
                  this.externalLinkEnabled = true;
                }
                get pagesCount() {
                  return 0;
                }
                get page() {
                  return 0;
                }
                set page(value) {
                }
                get rotation() {
                  return 0;
                }
                set rotation(value) {
                }
                get isInPresentationMode() {
                  return false;
                }
                async goToDestination(dest) {
                }
                goToPage(val) {
                }
                addLinkAttributes(link, url, newWindow = false) {
                  addLinkAttributes(link, {
                    url,
                    enabled: this.externalLinkEnabled
                  });
                }
                getDestinationHash(dest) {
                  return "#";
                }
                getAnchorUrl(hash) {
                  return "#";
                }
                setHash(hash) {
                }
                executeNamedAction(action) {
                }
                executeSetOCGState(action) {
                }
                cachePageRef(pageNum, pageRef) {
                }
              }
              exports2.SimpleLinkService = SimpleLinkService;
            },
            /* 6 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _onPresentationModeChanged, _updatePresentationModeState, updatePresentationModeState_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _l10n_utils = __w_pdfjs_require__2(7);
              var _ui_utils = __w_pdfjs_require__2(2);
              class AnnotationLayerBuilder {
                constructor({
                  pageDiv,
                  pdfPage,
                  linkService,
                  downloadManager,
                  annotationStorage = null,
                  imageResourcesPath = "",
                  renderForms = true,
                  l10n = _l10n_utils.NullL10n,
                  enableScripting = false,
                  hasJSActionsPromise = null,
                  fieldObjectsPromise = null,
                  annotationCanvasMap = null,
                  accessibilityManager = null
                }) {
                  __privateAdd(this, _updatePresentationModeState);
                  __privateAdd(this, _onPresentationModeChanged, null);
                  this.pageDiv = pageDiv;
                  this.pdfPage = pdfPage;
                  this.linkService = linkService;
                  this.downloadManager = downloadManager;
                  this.imageResourcesPath = imageResourcesPath;
                  this.renderForms = renderForms;
                  this.l10n = l10n;
                  this.annotationStorage = annotationStorage;
                  this.enableScripting = enableScripting;
                  this._hasJSActionsPromise = hasJSActionsPromise || Promise.resolve(false);
                  this._fieldObjectsPromise = fieldObjectsPromise || Promise.resolve(null);
                  this._annotationCanvasMap = annotationCanvasMap;
                  this._accessibilityManager = accessibilityManager;
                  this.annotationLayer = null;
                  this.div = null;
                  this._cancelled = false;
                  this._eventBus = linkService.eventBus;
                }
                async render(viewport, intent = "display") {
                  var _a;
                  if (this.div) {
                    if (this._cancelled || !this.annotationLayer) {
                      return;
                    }
                    this.annotationLayer.update({
                      viewport: viewport.clone({
                        dontFlip: true
                      })
                    });
                    return;
                  }
                  const [annotations, hasJSActions, fieldObjects] = await Promise.all([this.pdfPage.getAnnotations({
                    intent
                  }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
                  if (this._cancelled) {
                    return;
                  }
                  const div = this.div = document.createElement("div");
                  div.className = "annotationLayer";
                  this.pageDiv.append(div);
                  if (annotations.length === 0) {
                    this.hide();
                    return;
                  }
                  this.annotationLayer = new _pdfjsLib.AnnotationLayer({
                    div,
                    accessibilityManager: this._accessibilityManager,
                    annotationCanvasMap: this._annotationCanvasMap,
                    l10n: this.l10n,
                    page: this.pdfPage,
                    viewport: viewport.clone({
                      dontFlip: true
                    })
                  });
                  await this.annotationLayer.render({
                    annotations,
                    imageResourcesPath: this.imageResourcesPath,
                    renderForms: this.renderForms,
                    linkService: this.linkService,
                    downloadManager: this.downloadManager,
                    annotationStorage: this.annotationStorage,
                    enableScripting: this.enableScripting,
                    hasJSActions,
                    fieldObjects
                  });
                  if (this.linkService.isInPresentationMode) {
                    __privateMethod(this, _updatePresentationModeState, updatePresentationModeState_fn).call(this, _ui_utils.PresentationModeState.FULLSCREEN);
                  }
                  if (!__privateGet(this, _onPresentationModeChanged)) {
                    __privateSet(this, _onPresentationModeChanged, (evt) => {
                      __privateMethod(this, _updatePresentationModeState, updatePresentationModeState_fn).call(this, evt.state);
                    });
                    (_a = this._eventBus) == null ? void 0 : _a._on("presentationmodechanged", __privateGet(this, _onPresentationModeChanged));
                  }
                }
                cancel() {
                  var _a;
                  this._cancelled = true;
                  if (__privateGet(this, _onPresentationModeChanged)) {
                    (_a = this._eventBus) == null ? void 0 : _a._off("presentationmodechanged", __privateGet(this, _onPresentationModeChanged));
                    __privateSet(this, _onPresentationModeChanged, null);
                  }
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
              }
              _onPresentationModeChanged = new WeakMap();
              _updatePresentationModeState = new WeakSet();
              updatePresentationModeState_fn = function(state) {
                if (!this.div) {
                  return;
                }
                let disableFormElements = false;
                switch (state) {
                  case _ui_utils.PresentationModeState.FULLSCREEN:
                    disableFormElements = true;
                    break;
                  case _ui_utils.PresentationModeState.NORMAL:
                    break;
                  default:
                    return;
                }
                for (const section of this.div.childNodes) {
                  if (section.hasAttribute("data-internal-link")) {
                    continue;
                  }
                  section.inert = disableFormElements;
                }
              };
              exports2.AnnotationLayerBuilder = AnnotationLayerBuilder;
            },
            /* 7 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NullL10n = void 0;
              exports2.getL10nFallback = getL10nFallback;
              const DEFAULT_L10N_STRINGS = {
                of_pages: "of {{pagesCount}}",
                page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                document_properties_date_string: "{{date}}, {{time}}",
                document_properties_page_size_unit_inches: "in",
                document_properties_page_size_unit_millimeters: "mm",
                document_properties_page_size_orientation_portrait: "portrait",
                document_properties_page_size_orientation_landscape: "landscape",
                document_properties_page_size_name_a3: "A3",
                document_properties_page_size_name_a4: "A4",
                document_properties_page_size_name_letter: "Letter",
                document_properties_page_size_name_legal: "Legal",
                document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
                document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                document_properties_linearized_yes: "Yes",
                document_properties_linearized_no: "No",
                additional_layers: "Additional Layers",
                page_landmark: "Page {{page}}",
                thumb_page_title: "Page {{page}}",
                thumb_page_canvas: "Thumbnail of Page {{page}}",
                find_reached_top: "Reached top of document, continued from bottom",
                find_reached_bottom: "Reached end of document, continued from top",
                "find_match_count[one]": "{{current}} of {{total}} match",
                "find_match_count[other]": "{{current}} of {{total}} matches",
                "find_match_count_limit[one]": "More than {{limit}} match",
                "find_match_count_limit[other]": "More than {{limit}} matches",
                find_not_found: "Phrase not found",
                page_scale_width: "Page Width",
                page_scale_fit: "Page Fit",
                page_scale_auto: "Automatic Zoom",
                page_scale_actual: "Actual Size",
                page_scale_percent: "{{scale}}%",
                loading_error: "An error occurred while loading the PDF.",
                invalid_file_error: "Invalid or corrupted PDF file.",
                missing_file_error: "Missing PDF file.",
                unexpected_response_error: "Unexpected server response.",
                rendering_error: "An error occurred while rendering the page.",
                annotation_date_string: "{{date}}, {{time}}",
                printing_not_supported: "Warning: Printing is not fully supported by this browser.",
                printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
                web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
                free_text2_default_content: "Start typing…",
                editor_free_text2_aria_label: "Text Editor",
                editor_ink2_aria_label: "Draw Editor",
                editor_ink_canvas_aria_label: "User-created image"
              };
              {
                DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
              }
              function getL10nFallback(key, args) {
                switch (key) {
                  case "find_match_count":
                    key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
                    break;
                  case "find_match_count_limit":
                    key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
                    break;
                }
                return DEFAULT_L10N_STRINGS[key] || "";
              }
              function formatL10nValue(text, args) {
                if (!args) {
                  return text;
                }
                return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                  return name in args ? args[name] : "{{" + name + "}}";
                });
              }
              const NullL10n = {
                async getLanguage() {
                  return "en-us";
                },
                async getDirection() {
                  return "ltr";
                },
                async get(key, args = null, fallback = getL10nFallback(key, args)) {
                  return formatL10nValue(fallback, args);
                },
                async translate(element) {
                }
              };
              exports2.NullL10n = NullL10n;
            },
            /* 8 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _openBlobUrls;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DownloadManager = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              ;
              function download(blobUrl, filename) {
                const a = document.createElement("a");
                if (!a.click) {
                  throw new Error('DownloadManager: "a.click()" is not supported.');
                }
                a.href = blobUrl;
                a.target = "_parent";
                if ("download" in a) {
                  a.download = filename;
                }
                (document.body || document.documentElement).append(a);
                a.click();
                a.remove();
              }
              class DownloadManager {
                constructor() {
                  __privateAdd(this, _openBlobUrls, /* @__PURE__ */ new WeakMap());
                }
                downloadUrl(url, filename, _options) {
                  if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
                    console.error(`downloadUrl - not a valid URL: ${url}`);
                    return;
                  }
                  download(url + "#pdfjs.action=download", filename);
                }
                downloadData(data, filename, contentType) {
                  const blobUrl = URL.createObjectURL(new Blob([data], {
                    type: contentType
                  }));
                  download(blobUrl, filename);
                }
                openOrDownloadData(element, data, filename) {
                  const isPdfData = (0, _pdfjsLib.isPdfFile)(filename);
                  const contentType = isPdfData ? "application/pdf" : "";
                  this.downloadData(data, filename, contentType);
                  return false;
                }
                download(blob, url, filename, _options) {
                  const blobUrl = URL.createObjectURL(blob);
                  download(blobUrl, filename);
                }
              }
              _openBlobUrls = new WeakMap();
              exports2.DownloadManager = DownloadManager;
            },
            /* 9 */
            /***/
            (__unused_webpack_module, exports2) => {
              var _listeners;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.WaitOnType = exports2.EventBus = exports2.AutomationEventBus = void 0;
              exports2.waitOnEventOrTimeout = waitOnEventOrTimeout;
              const WaitOnType = {
                EVENT: "event",
                TIMEOUT: "timeout"
              };
              exports2.WaitOnType = WaitOnType;
              function waitOnEventOrTimeout({
                target,
                name,
                delay = 0
              }) {
                return new Promise(function(resolve, reject) {
                  if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
                    throw new Error("waitOnEventOrTimeout - invalid parameters.");
                  }
                  function handler(type) {
                    if (target instanceof EventBus) {
                      target._off(name, eventHandler);
                    } else {
                      target.removeEventListener(name, eventHandler);
                    }
                    if (timeout) {
                      clearTimeout(timeout);
                    }
                    resolve(type);
                  }
                  const eventHandler = handler.bind(null, WaitOnType.EVENT);
                  if (target instanceof EventBus) {
                    target._on(name, eventHandler);
                  } else {
                    target.addEventListener(name, eventHandler);
                  }
                  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
                  const timeout = setTimeout(timeoutHandler, delay);
                });
              }
              class EventBus {
                constructor() {
                  __privateAdd(this, _listeners, /* @__PURE__ */ Object.create(null));
                }
                on(eventName, listener, options = null) {
                  this._on(eventName, listener, {
                    external: true,
                    once: options == null ? void 0 : options.once
                  });
                }
                off(eventName, listener, options = null) {
                  this._off(eventName, listener, {
                    external: true,
                    once: options == null ? void 0 : options.once
                  });
                }
                dispatch(eventName, data) {
                  const eventListeners = __privateGet(this, _listeners)[eventName];
                  if (!eventListeners || eventListeners.length === 0) {
                    return;
                  }
                  let externalListeners;
                  for (const {
                    listener,
                    external,
                    once
                  } of eventListeners.slice(0)) {
                    if (once) {
                      this._off(eventName, listener);
                    }
                    if (external) {
                      (externalListeners || (externalListeners = [])).push(listener);
                      continue;
                    }
                    listener(data);
                  }
                  if (externalListeners) {
                    for (const listener of externalListeners) {
                      listener(data);
                    }
                    externalListeners = null;
                  }
                }
                _on(eventName, listener, options = null) {
                  var _a;
                  const eventListeners = (_a = __privateGet(this, _listeners))[eventName] || (_a[eventName] = []);
                  eventListeners.push({
                    listener,
                    external: (options == null ? void 0 : options.external) === true,
                    once: (options == null ? void 0 : options.once) === true
                  });
                }
                _off(eventName, listener, options = null) {
                  const eventListeners = __privateGet(this, _listeners)[eventName];
                  if (!eventListeners) {
                    return;
                  }
                  for (let i = 0, ii = eventListeners.length; i < ii; i++) {
                    if (eventListeners[i].listener === listener) {
                      eventListeners.splice(i, 1);
                      return;
                    }
                  }
                }
              }
              _listeners = new WeakMap();
              exports2.EventBus = EventBus;
              class AutomationEventBus extends EventBus {
                dispatch(eventName, data) {
                  throw new Error("Not implemented: AutomationEventBus.dispatch");
                }
              }
              exports2.AutomationEventBus = AutomationEventBus;
            },
            /* 10 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GenericL10n = void 0;
              __w_pdfjs_require__2(11);
              var _l10n_utils = __w_pdfjs_require__2(7);
              const PARTIAL_LANG_CODES = {
                en: "en-US",
                es: "es-ES",
                fy: "fy-NL",
                ga: "ga-IE",
                gu: "gu-IN",
                hi: "hi-IN",
                hy: "hy-AM",
                nb: "nb-NO",
                ne: "ne-NP",
                nn: "nn-NO",
                pa: "pa-IN",
                pt: "pt-PT",
                sv: "sv-SE",
                zh: "zh-CN"
              };
              function fixupLangCode(langCode) {
                return PARTIAL_LANG_CODES[langCode == null ? void 0 : langCode.toLowerCase()] || langCode;
              }
              class GenericL10n {
                constructor(lang) {
                  const {
                    webL10n
                  } = document;
                  this._lang = lang;
                  this._ready = new Promise((resolve, reject) => {
                    webL10n.setLanguage(fixupLangCode(lang), () => {
                      resolve(webL10n);
                    });
                  });
                }
                async getLanguage() {
                  const l10n = await this._ready;
                  return l10n.getLanguage();
                }
                async getDirection() {
                  const l10n = await this._ready;
                  return l10n.getDirection();
                }
                async get(key, args = null, fallback = (0, _l10n_utils.getL10nFallback)(key, args)) {
                  const l10n = await this._ready;
                  return l10n.get(key, args, fallback);
                }
                async translate(element) {
                  const l10n = await this._ready;
                  return l10n.translate(element);
                }
              }
              exports2.GenericL10n = GenericL10n;
            },
            /* 11 */
            /***/
            () => {
              document.webL10n = function(window2, document2) {
                var gL10nData = {};
                var gTextData = "";
                var gTextProp = "textContent";
                var gLanguage = "";
                var gMacros = {};
                var gReadyState = "loading";
                var gAsyncResourceLoading = true;
                function getL10nResourceLinks() {
                  return document2.querySelectorAll('link[type="application/l10n"]');
                }
                function getL10nDictionary() {
                  var script = document2.querySelector('script[type="application/l10n"]');
                  return script ? JSON.parse(script.innerHTML) : null;
                }
                function getTranslatableChildren(element) {
                  return element ? element.querySelectorAll("*[data-l10n-id]") : [];
                }
                function getL10nAttributes(element) {
                  if (!element)
                    return {};
                  var l10nId = element.getAttribute("data-l10n-id");
                  var l10nArgs = element.getAttribute("data-l10n-args");
                  var args = {};
                  if (l10nArgs) {
                    try {
                      args = JSON.parse(l10nArgs);
                    } catch (e) {
                      console.warn("could not parse arguments for #" + l10nId);
                    }
                  }
                  return {
                    id: l10nId,
                    args
                  };
                }
                function xhrLoadText(url, onSuccess, onFailure) {
                  onSuccess = onSuccess || function _onSuccess(data) {
                  };
                  onFailure = onFailure || function _onFailure() {
                  };
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, gAsyncResourceLoading);
                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=utf-8");
                  }
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                      if (xhr.status == 200 || xhr.status === 0) {
                        onSuccess(xhr.responseText);
                      } else {
                        onFailure();
                      }
                    }
                  };
                  xhr.onerror = onFailure;
                  xhr.ontimeout = onFailure;
                  try {
                    xhr.send(null);
                  } catch (e) {
                    onFailure();
                  }
                }
                function parseResource(href, lang, successCallback, failureCallback) {
                  var baseURL = href.replace(/[^\/]*$/, "") || "./";
                  function evalString(text) {
                    if (text.lastIndexOf("\\") < 0)
                      return text;
                    return text.replace(/\\\\/g, "\\").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/\\"/g, '"').replace(/\\'/g, "'");
                  }
                  function parseProperties(text, parsedPropertiesCallback) {
                    var dictionary = {};
                    var reBlank = /^\s*|\s*$/;
                    var reComment = /^\s*#|^\s*$/;
                    var reSection = /^\s*\[(.*)\]\s*$/;
                    var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
                    var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;
                    function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
                      var entries = rawText.replace(reBlank, "").split(/[\r\n]+/);
                      var currentLang = "*";
                      var genericLang = lang.split("-", 1)[0];
                      var skipLang = false;
                      var match = "";
                      function nextEntry() {
                        while (true) {
                          if (!entries.length) {
                            parsedRawLinesCallback();
                            return;
                          }
                          var line = entries.shift();
                          if (reComment.test(line))
                            continue;
                          if (extendedSyntax) {
                            match = reSection.exec(line);
                            if (match) {
                              currentLang = match[1].toLowerCase();
                              skipLang = currentLang !== "*" && currentLang !== lang && currentLang !== genericLang;
                              continue;
                            } else if (skipLang) {
                              continue;
                            }
                            match = reImport.exec(line);
                            if (match) {
                              loadImport(baseURL + match[1], nextEntry);
                              return;
                            }
                          }
                          var tmp = line.match(reSplit);
                          if (tmp && tmp.length == 3) {
                            dictionary[tmp[1]] = evalString(tmp[2]);
                          }
                        }
                      }
                      nextEntry();
                    }
                    function loadImport(url, callback) {
                      xhrLoadText(url, function(content) {
                        parseRawLines(content, false, callback);
                      }, function() {
                        console.warn(url + " not found.");
                        callback();
                      });
                    }
                    parseRawLines(text, true, function() {
                      parsedPropertiesCallback(dictionary);
                    });
                  }
                  xhrLoadText(href, function(response) {
                    gTextData += response;
                    parseProperties(response, function(data) {
                      for (var key in data) {
                        var id, prop, index = key.lastIndexOf(".");
                        if (index > 0) {
                          id = key.substring(0, index);
                          prop = key.substring(index + 1);
                        } else {
                          id = key;
                          prop = gTextProp;
                        }
                        if (!gL10nData[id]) {
                          gL10nData[id] = {};
                        }
                        gL10nData[id][prop] = data[key];
                      }
                      if (successCallback) {
                        successCallback();
                      }
                    });
                  }, failureCallback);
                }
                function loadLocale(lang, callback) {
                  if (lang) {
                    lang = lang.toLowerCase();
                  }
                  callback = callback || function _callback() {
                  };
                  clear();
                  gLanguage = lang;
                  var langLinks = getL10nResourceLinks();
                  var langCount = langLinks.length;
                  if (langCount === 0) {
                    var dict = getL10nDictionary();
                    if (dict && dict.locales && dict.default_locale) {
                      console.log("using the embedded JSON directory, early way out");
                      gL10nData = dict.locales[lang];
                      if (!gL10nData) {
                        var defaultLocale = dict.default_locale.toLowerCase();
                        for (var anyCaseLang in dict.locales) {
                          anyCaseLang = anyCaseLang.toLowerCase();
                          if (anyCaseLang === lang) {
                            gL10nData = dict.locales[lang];
                            break;
                          } else if (anyCaseLang === defaultLocale) {
                            gL10nData = dict.locales[defaultLocale];
                          }
                        }
                      }
                      callback();
                    } else {
                      console.log("no resource to load, early way out");
                    }
                    gReadyState = "complete";
                    return;
                  }
                  var onResourceLoaded = null;
                  var gResourceCount = 0;
                  onResourceLoaded = function() {
                    gResourceCount++;
                    if (gResourceCount >= langCount) {
                      callback();
                      gReadyState = "complete";
                    }
                  };
                  function L10nResourceLink(link) {
                    var href = link.href;
                    this.load = function(lang2, callback2) {
                      parseResource(href, lang2, callback2, function() {
                        console.warn(href + " not found.");
                        console.warn('"' + lang2 + '" resource not found');
                        gLanguage = "";
                        callback2();
                      });
                    };
                  }
                  for (var i = 0; i < langCount; i++) {
                    var resource = new L10nResourceLink(langLinks[i]);
                    resource.load(lang, onResourceLoaded);
                  }
                }
                function clear() {
                  gL10nData = {};
                  gTextData = "";
                  gLanguage = "";
                }
                function getPluralRules(lang) {
                  var locales2rules = {
                    "af": 3,
                    "ak": 4,
                    "am": 4,
                    "ar": 1,
                    "asa": 3,
                    "az": 0,
                    "be": 11,
                    "bem": 3,
                    "bez": 3,
                    "bg": 3,
                    "bh": 4,
                    "bm": 0,
                    "bn": 3,
                    "bo": 0,
                    "br": 20,
                    "brx": 3,
                    "bs": 11,
                    "ca": 3,
                    "cgg": 3,
                    "chr": 3,
                    "cs": 12,
                    "cy": 17,
                    "da": 3,
                    "de": 3,
                    "dv": 3,
                    "dz": 0,
                    "ee": 3,
                    "el": 3,
                    "en": 3,
                    "eo": 3,
                    "es": 3,
                    "et": 3,
                    "eu": 3,
                    "fa": 0,
                    "ff": 5,
                    "fi": 3,
                    "fil": 4,
                    "fo": 3,
                    "fr": 5,
                    "fur": 3,
                    "fy": 3,
                    "ga": 8,
                    "gd": 24,
                    "gl": 3,
                    "gsw": 3,
                    "gu": 3,
                    "guw": 4,
                    "gv": 23,
                    "ha": 3,
                    "haw": 3,
                    "he": 2,
                    "hi": 4,
                    "hr": 11,
                    "hu": 0,
                    "id": 0,
                    "ig": 0,
                    "ii": 0,
                    "is": 3,
                    "it": 3,
                    "iu": 7,
                    "ja": 0,
                    "jmc": 3,
                    "jv": 0,
                    "ka": 0,
                    "kab": 5,
                    "kaj": 3,
                    "kcg": 3,
                    "kde": 0,
                    "kea": 0,
                    "kk": 3,
                    "kl": 3,
                    "km": 0,
                    "kn": 0,
                    "ko": 0,
                    "ksb": 3,
                    "ksh": 21,
                    "ku": 3,
                    "kw": 7,
                    "lag": 18,
                    "lb": 3,
                    "lg": 3,
                    "ln": 4,
                    "lo": 0,
                    "lt": 10,
                    "lv": 6,
                    "mas": 3,
                    "mg": 4,
                    "mk": 16,
                    "ml": 3,
                    "mn": 3,
                    "mo": 9,
                    "mr": 3,
                    "ms": 0,
                    "mt": 15,
                    "my": 0,
                    "nah": 3,
                    "naq": 7,
                    "nb": 3,
                    "nd": 3,
                    "ne": 3,
                    "nl": 3,
                    "nn": 3,
                    "no": 3,
                    "nr": 3,
                    "nso": 4,
                    "ny": 3,
                    "nyn": 3,
                    "om": 3,
                    "or": 3,
                    "pa": 3,
                    "pap": 3,
                    "pl": 13,
                    "ps": 3,
                    "pt": 3,
                    "rm": 3,
                    "ro": 9,
                    "rof": 3,
                    "ru": 11,
                    "rwk": 3,
                    "sah": 0,
                    "saq": 3,
                    "se": 7,
                    "seh": 3,
                    "ses": 0,
                    "sg": 0,
                    "sh": 11,
                    "shi": 19,
                    "sk": 12,
                    "sl": 14,
                    "sma": 7,
                    "smi": 7,
                    "smj": 7,
                    "smn": 7,
                    "sms": 7,
                    "sn": 3,
                    "so": 3,
                    "sq": 3,
                    "sr": 11,
                    "ss": 3,
                    "ssy": 3,
                    "st": 3,
                    "sv": 3,
                    "sw": 3,
                    "syr": 3,
                    "ta": 3,
                    "te": 3,
                    "teo": 3,
                    "th": 0,
                    "ti": 4,
                    "tig": 3,
                    "tk": 3,
                    "tl": 4,
                    "tn": 3,
                    "to": 0,
                    "tr": 0,
                    "ts": 3,
                    "tzm": 22,
                    "uk": 11,
                    "ur": 3,
                    "ve": 3,
                    "vi": 0,
                    "vun": 3,
                    "wa": 4,
                    "wae": 3,
                    "wo": 0,
                    "xh": 3,
                    "xog": 3,
                    "yo": 0,
                    "zh": 0,
                    "zu": 3
                  };
                  function isIn(n, list) {
                    return list.indexOf(n) !== -1;
                  }
                  function isBetween(n, start, end) {
                    return start <= n && n <= end;
                  }
                  var pluralRules = {
                    "0": function(n) {
                      return "other";
                    },
                    "1": function(n) {
                      if (isBetween(n % 100, 3, 10))
                        return "few";
                      if (n === 0)
                        return "zero";
                      if (isBetween(n % 100, 11, 99))
                        return "many";
                      if (n == 2)
                        return "two";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "2": function(n) {
                      if (n !== 0 && n % 10 === 0)
                        return "many";
                      if (n == 2)
                        return "two";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "3": function(n) {
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "4": function(n) {
                      if (isBetween(n, 0, 1))
                        return "one";
                      return "other";
                    },
                    "5": function(n) {
                      if (isBetween(n, 0, 2) && n != 2)
                        return "one";
                      return "other";
                    },
                    "6": function(n) {
                      if (n === 0)
                        return "zero";
                      if (n % 10 == 1 && n % 100 != 11)
                        return "one";
                      return "other";
                    },
                    "7": function(n) {
                      if (n == 2)
                        return "two";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "8": function(n) {
                      if (isBetween(n, 3, 6))
                        return "few";
                      if (isBetween(n, 7, 10))
                        return "many";
                      if (n == 2)
                        return "two";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "9": function(n) {
                      if (n === 0 || n != 1 && isBetween(n % 100, 1, 19))
                        return "few";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "10": function(n) {
                      if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19))
                        return "few";
                      if (n % 10 == 1 && !isBetween(n % 100, 11, 19))
                        return "one";
                      return "other";
                    },
                    "11": function(n) {
                      if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14))
                        return "few";
                      if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14))
                        return "many";
                      if (n % 10 == 1 && n % 100 != 11)
                        return "one";
                      return "other";
                    },
                    "12": function(n) {
                      if (isBetween(n, 2, 4))
                        return "few";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "13": function(n) {
                      if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14))
                        return "few";
                      if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14))
                        return "many";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "14": function(n) {
                      if (isBetween(n % 100, 3, 4))
                        return "few";
                      if (n % 100 == 2)
                        return "two";
                      if (n % 100 == 1)
                        return "one";
                      return "other";
                    },
                    "15": function(n) {
                      if (n === 0 || isBetween(n % 100, 2, 10))
                        return "few";
                      if (isBetween(n % 100, 11, 19))
                        return "many";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "16": function(n) {
                      if (n % 10 == 1 && n != 11)
                        return "one";
                      return "other";
                    },
                    "17": function(n) {
                      if (n == 3)
                        return "few";
                      if (n === 0)
                        return "zero";
                      if (n == 6)
                        return "many";
                      if (n == 2)
                        return "two";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "18": function(n) {
                      if (n === 0)
                        return "zero";
                      if (isBetween(n, 0, 2) && n !== 0 && n != 2)
                        return "one";
                      return "other";
                    },
                    "19": function(n) {
                      if (isBetween(n, 2, 10))
                        return "few";
                      if (isBetween(n, 0, 1))
                        return "one";
                      return "other";
                    },
                    "20": function(n) {
                      if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99)))
                        return "few";
                      if (n % 1e6 === 0 && n !== 0)
                        return "many";
                      if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92]))
                        return "two";
                      if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91]))
                        return "one";
                      return "other";
                    },
                    "21": function(n) {
                      if (n === 0)
                        return "zero";
                      if (n == 1)
                        return "one";
                      return "other";
                    },
                    "22": function(n) {
                      if (isBetween(n, 0, 1) || isBetween(n, 11, 99))
                        return "one";
                      return "other";
                    },
                    "23": function(n) {
                      if (isBetween(n % 10, 1, 2) || n % 20 === 0)
                        return "one";
                      return "other";
                    },
                    "24": function(n) {
                      if (isBetween(n, 3, 10) || isBetween(n, 13, 19))
                        return "few";
                      if (isIn(n, [2, 12]))
                        return "two";
                      if (isIn(n, [1, 11]))
                        return "one";
                      return "other";
                    }
                  };
                  var index = locales2rules[lang.replace(/-.*$/, "")];
                  if (!(index in pluralRules)) {
                    console.warn("plural form unknown for [" + lang + "]");
                    return function() {
                      return "other";
                    };
                  }
                  return pluralRules[index];
                }
                gMacros.plural = function(str, param, key, prop) {
                  var n = parseFloat(param);
                  if (isNaN(n))
                    return str;
                  if (prop != gTextProp)
                    return str;
                  if (!gMacros._pluralRules) {
                    gMacros._pluralRules = getPluralRules(gLanguage);
                  }
                  var index = "[" + gMacros._pluralRules(n) + "]";
                  if (n === 0 && key + "[zero]" in gL10nData) {
                    str = gL10nData[key + "[zero]"][prop];
                  } else if (n == 1 && key + "[one]" in gL10nData) {
                    str = gL10nData[key + "[one]"][prop];
                  } else if (n == 2 && key + "[two]" in gL10nData) {
                    str = gL10nData[key + "[two]"][prop];
                  } else if (key + index in gL10nData) {
                    str = gL10nData[key + index][prop];
                  } else if (key + "[other]" in gL10nData) {
                    str = gL10nData[key + "[other]"][prop];
                  }
                  return str;
                };
                function getL10nData(key, args, fallback) {
                  var data = gL10nData[key];
                  if (!data) {
                    console.warn("#" + key + " is undefined.");
                    if (!fallback) {
                      return null;
                    }
                    data = fallback;
                  }
                  var rv = {};
                  for (var prop in data) {
                    var str = data[prop];
                    str = substIndexes(str, args, key, prop);
                    str = substArguments(str, args, key);
                    rv[prop] = str;
                  }
                  return rv;
                }
                function substIndexes(str, args, key, prop) {
                  var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
                  var reMatch = reIndex.exec(str);
                  if (!reMatch || !reMatch.length)
                    return str;
                  var macroName = reMatch[1];
                  var paramName = reMatch[2];
                  var param;
                  if (args && paramName in args) {
                    param = args[paramName];
                  } else if (paramName in gL10nData) {
                    param = gL10nData[paramName];
                  }
                  if (macroName in gMacros) {
                    var macro = gMacros[macroName];
                    str = macro(str, param, key, prop);
                  }
                  return str;
                }
                function substArguments(str, args, key) {
                  var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
                  return str.replace(reArgs, function(matched_text, arg) {
                    if (args && arg in args) {
                      return args[arg];
                    }
                    if (arg in gL10nData) {
                      return gL10nData[arg];
                    }
                    console.log("argument {{" + arg + "}} for #" + key + " is undefined.");
                    return matched_text;
                  });
                }
                function translateElement(element) {
                  var l10n = getL10nAttributes(element);
                  if (!l10n.id)
                    return;
                  var data = getL10nData(l10n.id, l10n.args);
                  if (!data) {
                    console.warn("#" + l10n.id + " is undefined.");
                    return;
                  }
                  if (data[gTextProp]) {
                    if (getChildElementCount(element) === 0) {
                      element[gTextProp] = data[gTextProp];
                    } else {
                      var children = element.childNodes;
                      var found = false;
                      for (var i = 0, l = children.length; i < l; i++) {
                        if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                          if (found) {
                            children[i].nodeValue = "";
                          } else {
                            children[i].nodeValue = data[gTextProp];
                            found = true;
                          }
                        }
                      }
                      if (!found) {
                        var textNode = document2.createTextNode(data[gTextProp]);
                        element.prepend(textNode);
                      }
                    }
                    delete data[gTextProp];
                  }
                  for (var k in data) {
                    element[k] = data[k];
                  }
                }
                function getChildElementCount(element) {
                  if (element.children) {
                    return element.children.length;
                  }
                  if (typeof element.childElementCount !== "undefined") {
                    return element.childElementCount;
                  }
                  var count = 0;
                  for (var i = 0; i < element.childNodes.length; i++) {
                    count += element.nodeType === 1 ? 1 : 0;
                  }
                  return count;
                }
                function translateFragment(element) {
                  element = element || document2.documentElement;
                  var children = getTranslatableChildren(element);
                  var elementCount = children.length;
                  for (var i = 0; i < elementCount; i++) {
                    translateElement(children[i]);
                  }
                  translateElement(element);
                }
                return {
                  get: function(key, args, fallbackString) {
                    var index = key.lastIndexOf(".");
                    var prop = gTextProp;
                    if (index > 0) {
                      prop = key.substring(index + 1);
                      key = key.substring(0, index);
                    }
                    var fallback;
                    if (fallbackString) {
                      fallback = {};
                      fallback[prop] = fallbackString;
                    }
                    var data = getL10nData(key, args, fallback);
                    if (data && prop in data) {
                      return data[prop];
                    }
                    return "{{" + key + "}}";
                  },
                  getData: function() {
                    return gL10nData;
                  },
                  getText: function() {
                    return gTextData;
                  },
                  getLanguage: function() {
                    return gLanguage;
                  },
                  setLanguage: function(lang, callback) {
                    loadLocale(lang, function() {
                      if (callback)
                        callback();
                    });
                  },
                  getDirection: function() {
                    var rtlList = ["ar", "he", "fa", "ps", "ur"];
                    var shortCode = gLanguage.split("-", 1)[0];
                    return rtlList.indexOf(shortCode) >= 0 ? "rtl" : "ltr";
                  },
                  translate: translateFragment,
                  getReadyState: function() {
                    return gReadyState;
                  },
                  ready: function(callback) {
                    if (!callback) {
                      return;
                    } else if (gReadyState == "complete" || gReadyState == "interactive") {
                      window2.setTimeout(function() {
                        callback();
                      });
                    } else if (document2.addEventListener) {
                      document2.addEventListener("localized", function once() {
                        document2.removeEventListener("localized", once);
                        callback();
                      });
                    }
                  }
                };
              }(window, document);
            },
            /* 12 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFHistory = void 0;
              exports2.isDestArraysEqual = isDestArraysEqual;
              exports2.isDestHashesEqual = isDestHashesEqual;
              var _ui_utils = __w_pdfjs_require__2(2);
              var _event_utils = __w_pdfjs_require__2(9);
              const HASH_CHANGE_TIMEOUT = 1e3;
              const POSITION_UPDATED_THRESHOLD = 50;
              const UPDATE_VIEWAREA_TIMEOUT = 1e3;
              function getCurrentHash() {
                return document.location.hash;
              }
              class PDFHistory {
                constructor({
                  linkService,
                  eventBus
                }) {
                  this.linkService = linkService;
                  this.eventBus = eventBus;
                  this._initialized = false;
                  this._fingerprint = "";
                  this.reset();
                  this._boundEvents = null;
                  this.eventBus._on("pagesinit", () => {
                    this._isPagesLoaded = false;
                    this.eventBus._on("pagesloaded", (evt) => {
                      this._isPagesLoaded = !!evt.pagesCount;
                    }, {
                      once: true
                    });
                  });
                }
                initialize({
                  fingerprint,
                  resetHistory = false,
                  updateUrl = false
                }) {
                  if (!fingerprint || typeof fingerprint !== "string") {
                    console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                    return;
                  }
                  if (this._initialized) {
                    this.reset();
                  }
                  const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
                  this._fingerprint = fingerprint;
                  this._updateUrl = updateUrl === true;
                  this._initialized = true;
                  this._bindEvents();
                  const state = window.history.state;
                  this._popStateInProgress = false;
                  this._blockHashChange = 0;
                  this._currentHash = getCurrentHash();
                  this._numPositionUpdates = 0;
                  this._uid = this._maxUid = 0;
                  this._destination = null;
                  this._position = null;
                  if (!this._isValidState(state, true) || resetHistory) {
                    const {
                      hash,
                      page,
                      rotation
                    } = this._parseCurrentHash(true);
                    if (!hash || reInitialized || resetHistory) {
                      this._pushOrReplaceState(null, true);
                      return;
                    }
                    this._pushOrReplaceState({
                      hash,
                      page,
                      rotation
                    }, true);
                    return;
                  }
                  const destination = state.destination;
                  this._updateInternalState(destination, state.uid, true);
                  if (destination.rotation !== void 0) {
                    this._initialRotation = destination.rotation;
                  }
                  if (destination.dest) {
                    this._initialBookmark = JSON.stringify(destination.dest);
                    this._destination.page = null;
                  } else if (destination.hash) {
                    this._initialBookmark = destination.hash;
                  } else if (destination.page) {
                    this._initialBookmark = `page=${destination.page}`;
                  }
                }
                reset() {
                  if (this._initialized) {
                    this._pageHide();
                    this._initialized = false;
                    this._unbindEvents();
                  }
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  this._initialBookmark = null;
                  this._initialRotation = null;
                }
                push({
                  namedDest = null,
                  explicitDest,
                  pageNumber
                }) {
                  if (!this._initialized) {
                    return;
                  }
                  if (namedDest && typeof namedDest !== "string") {
                    console.error(`PDFHistory.push: "${namedDest}" is not a valid namedDest parameter.`);
                    return;
                  } else if (!Array.isArray(explicitDest)) {
                    console.error(`PDFHistory.push: "${explicitDest}" is not a valid explicitDest parameter.`);
                    return;
                  } else if (!this._isValidPage(pageNumber)) {
                    if (pageNumber !== null || this._destination) {
                      console.error(`PDFHistory.push: "${pageNumber}" is not a valid pageNumber parameter.`);
                      return;
                    }
                  }
                  const hash = namedDest || JSON.stringify(explicitDest);
                  if (!hash) {
                    return;
                  }
                  let forceReplace = false;
                  if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
                    if (this._destination.page) {
                      return;
                    }
                    forceReplace = true;
                  }
                  if (this._popStateInProgress && !forceReplace) {
                    return;
                  }
                  this._pushOrReplaceState({
                    dest: explicitDest,
                    hash,
                    page: pageNumber,
                    rotation: this.linkService.rotation
                  }, forceReplace);
                  if (!this._popStateInProgress) {
                    this._popStateInProgress = true;
                    Promise.resolve().then(() => {
                      this._popStateInProgress = false;
                    });
                  }
                }
                pushPage(pageNumber) {
                  var _a;
                  if (!this._initialized) {
                    return;
                  }
                  if (!this._isValidPage(pageNumber)) {
                    console.error(`PDFHistory.pushPage: "${pageNumber}" is not a valid page number.`);
                    return;
                  }
                  if (((_a = this._destination) == null ? void 0 : _a.page) === pageNumber) {
                    return;
                  }
                  if (this._popStateInProgress) {
                    return;
                  }
                  this._pushOrReplaceState({
                    dest: null,
                    hash: `page=${pageNumber}`,
                    page: pageNumber,
                    rotation: this.linkService.rotation
                  });
                  if (!this._popStateInProgress) {
                    this._popStateInProgress = true;
                    Promise.resolve().then(() => {
                      this._popStateInProgress = false;
                    });
                  }
                }
                pushCurrentPosition() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  this._tryPushCurrentPosition();
                }
                back() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  const state = window.history.state;
                  if (this._isValidState(state) && state.uid > 0) {
                    window.history.back();
                  }
                }
                forward() {
                  if (!this._initialized || this._popStateInProgress) {
                    return;
                  }
                  const state = window.history.state;
                  if (this._isValidState(state) && state.uid < this._maxUid) {
                    window.history.forward();
                  }
                }
                get popStateInProgress() {
                  return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
                }
                get initialBookmark() {
                  return this._initialized ? this._initialBookmark : null;
                }
                get initialRotation() {
                  return this._initialized ? this._initialRotation : null;
                }
                _pushOrReplaceState(destination, forceReplace = false) {
                  const shouldReplace = forceReplace || !this._destination;
                  const newState = {
                    fingerprint: this._fingerprint,
                    uid: shouldReplace ? this._uid : this._uid + 1,
                    destination
                  };
                  this._updateInternalState(destination, newState.uid);
                  let newUrl;
                  if (this._updateUrl && (destination == null ? void 0 : destination.hash)) {
                    const baseUrl = document.location.href.split("#")[0];
                    if (!baseUrl.startsWith("file://")) {
                      newUrl = `${baseUrl}#${destination.hash}`;
                    }
                  }
                  if (shouldReplace) {
                    window.history.replaceState(newState, "", newUrl);
                  } else {
                    window.history.pushState(newState, "", newUrl);
                  }
                }
                _tryPushCurrentPosition(temporary = false) {
                  if (!this._position) {
                    return;
                  }
                  let position = this._position;
                  if (temporary) {
                    position = Object.assign(/* @__PURE__ */ Object.create(null), this._position);
                    position.temporary = true;
                  }
                  if (!this._destination) {
                    this._pushOrReplaceState(position);
                    return;
                  }
                  if (this._destination.temporary) {
                    this._pushOrReplaceState(position, true);
                    return;
                  }
                  if (this._destination.hash === position.hash) {
                    return;
                  }
                  if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
                    return;
                  }
                  let forceReplace = false;
                  if (this._destination.page >= position.first && this._destination.page <= position.page) {
                    if (this._destination.dest !== void 0 || !this._destination.first) {
                      return;
                    }
                    forceReplace = true;
                  }
                  this._pushOrReplaceState(position, forceReplace);
                }
                _isValidPage(val) {
                  return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
                }
                _isValidState(state, checkReload = false) {
                  if (!state) {
                    return false;
                  }
                  if (state.fingerprint !== this._fingerprint) {
                    if (checkReload) {
                      if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                        return false;
                      }
                      const [perfEntry] = performance.getEntriesByType("navigation");
                      if ((perfEntry == null ? void 0 : perfEntry.type) !== "reload") {
                        return false;
                      }
                    } else {
                      return false;
                    }
                  }
                  if (!Number.isInteger(state.uid) || state.uid < 0) {
                    return false;
                  }
                  if (state.destination === null || typeof state.destination !== "object") {
                    return false;
                  }
                  return true;
                }
                _updateInternalState(destination, uid, removeTemporary = false) {
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  if (removeTemporary && (destination == null ? void 0 : destination.temporary)) {
                    delete destination.temporary;
                  }
                  this._destination = destination;
                  this._uid = uid;
                  this._maxUid = Math.max(this._maxUid, uid);
                  this._numPositionUpdates = 0;
                }
                _parseCurrentHash(checkNameddest = false) {
                  const hash = unescape(getCurrentHash()).substring(1);
                  const params = (0, _ui_utils.parseQueryString)(hash);
                  const nameddest = params.get("nameddest") || "";
                  let page = params.get("page") | 0;
                  if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
                    page = null;
                  }
                  return {
                    hash,
                    page,
                    rotation: this.linkService.rotation
                  };
                }
                _updateViewarea({
                  location
                }) {
                  if (this._updateViewareaTimeout) {
                    clearTimeout(this._updateViewareaTimeout);
                    this._updateViewareaTimeout = null;
                  }
                  this._position = {
                    hash: location.pdfOpenParams.substring(1),
                    page: this.linkService.page,
                    first: location.pageNumber,
                    rotation: location.rotation
                  };
                  if (this._popStateInProgress) {
                    return;
                  }
                  if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
                    this._numPositionUpdates++;
                  }
                  if (UPDATE_VIEWAREA_TIMEOUT > 0) {
                    this._updateViewareaTimeout = setTimeout(() => {
                      if (!this._popStateInProgress) {
                        this._tryPushCurrentPosition(true);
                      }
                      this._updateViewareaTimeout = null;
                    }, UPDATE_VIEWAREA_TIMEOUT);
                  }
                }
                _popState({
                  state
                }) {
                  const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;
                  this._currentHash = newHash;
                  if (!state) {
                    this._uid++;
                    const {
                      hash,
                      page,
                      rotation
                    } = this._parseCurrentHash();
                    this._pushOrReplaceState({
                      hash,
                      page,
                      rotation
                    }, true);
                    return;
                  }
                  if (!this._isValidState(state)) {
                    return;
                  }
                  this._popStateInProgress = true;
                  if (hashChanged) {
                    this._blockHashChange++;
                    (0, _event_utils.waitOnEventOrTimeout)({
                      target: window,
                      name: "hashchange",
                      delay: HASH_CHANGE_TIMEOUT
                    }).then(() => {
                      this._blockHashChange--;
                    });
                  }
                  const destination = state.destination;
                  this._updateInternalState(destination, state.uid, true);
                  if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
                    this.linkService.rotation = destination.rotation;
                  }
                  if (destination.dest) {
                    this.linkService.goToDestination(destination.dest);
                  } else if (destination.hash) {
                    this.linkService.setHash(destination.hash);
                  } else if (destination.page) {
                    this.linkService.page = destination.page;
                  }
                  Promise.resolve().then(() => {
                    this._popStateInProgress = false;
                  });
                }
                _pageHide() {
                  if (!this._destination || this._destination.temporary) {
                    this._tryPushCurrentPosition();
                  }
                }
                _bindEvents() {
                  if (this._boundEvents) {
                    return;
                  }
                  this._boundEvents = {
                    updateViewarea: this._updateViewarea.bind(this),
                    popState: this._popState.bind(this),
                    pageHide: this._pageHide.bind(this)
                  };
                  this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);
                  window.addEventListener("popstate", this._boundEvents.popState);
                  window.addEventListener("pagehide", this._boundEvents.pageHide);
                }
                _unbindEvents() {
                  if (!this._boundEvents) {
                    return;
                  }
                  this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);
                  window.removeEventListener("popstate", this._boundEvents.popState);
                  window.removeEventListener("pagehide", this._boundEvents.pageHide);
                  this._boundEvents = null;
                }
              }
              exports2.PDFHistory = PDFHistory;
              function isDestHashesEqual(destHash, pushHash) {
                if (typeof destHash !== "string" || typeof pushHash !== "string") {
                  return false;
                }
                if (destHash === pushHash) {
                  return true;
                }
                const nameddest = (0, _ui_utils.parseQueryString)(destHash).get("nameddest");
                if (nameddest === pushHash) {
                  return true;
                }
                return false;
              }
              function isDestArraysEqual(firstDest, secondDest) {
                function isEntryEqual(first, second) {
                  if (typeof first !== typeof second) {
                    return false;
                  }
                  if (Array.isArray(first) || Array.isArray(second)) {
                    return false;
                  }
                  if (first !== null && typeof first === "object" && second !== null) {
                    if (Object.keys(first).length !== Object.keys(second).length) {
                      return false;
                    }
                    for (const key in first) {
                      if (!isEntryEqual(first[key], second[key])) {
                        return false;
                      }
                    }
                    return true;
                  }
                  return first === second || Number.isNaN(first) && Number.isNaN(second);
                }
                if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
                  return false;
                }
                if (firstDest.length !== secondDest.length) {
                  return false;
                }
                for (let i = 0, ii = firstDest.length; i < ii; i++) {
                  if (!isEntryEqual(firstDest[i], secondDest[i])) {
                    return false;
                  }
                }
                return true;
              }
            },
            /* 13 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _annotationMode, _hasRestrictedScaling, _layerProperties, _loadingId, _previousRotation, _renderError, _renderingState, _textLayerMode, _useThumbnailCanvas, _viewportMap, _setDimensions, setDimensions_fn, _renderAnnotationLayer, renderAnnotationLayer_fn, _renderAnnotationEditorLayer, renderAnnotationEditorLayer_fn, _renderXfaLayer, renderXfaLayer_fn, _renderTextLayer, renderTextLayer_fn, _renderStructTreeLayer, renderStructTreeLayer_fn, _buildXfaTextContentItems, buildXfaTextContentItems_fn, _finishRenderTask, finishRenderTask_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFPageView = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _ui_utils = __w_pdfjs_require__2(2);
              var _annotation_editor_layer_builder = __w_pdfjs_require__2(14);
              var _annotation_layer_builder = __w_pdfjs_require__2(6);
              var _app_options = __w_pdfjs_require__2(15);
              var _l10n_utils = __w_pdfjs_require__2(7);
              var _pdf_link_service = __w_pdfjs_require__2(5);
              var _struct_tree_layer_builder = __w_pdfjs_require__2(16);
              var _text_accessibility = __w_pdfjs_require__2(17);
              var _text_highlighter = __w_pdfjs_require__2(18);
              var _text_layer_builder = __w_pdfjs_require__2(19);
              var _xfa_layer_builder = __w_pdfjs_require__2(20);
              const MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216;
              const DEFAULT_LAYER_PROPERTIES = () => {
                return {
                  annotationEditorUIManager: null,
                  annotationStorage: null,
                  downloadManager: null,
                  enableScripting: false,
                  fieldObjectsPromise: null,
                  findController: null,
                  hasJSActionsPromise: null,
                  get linkService() {
                    return new _pdf_link_service.SimpleLinkService();
                  }
                };
              };
              class PDFPageView {
                constructor(options) {
                  __privateAdd(this, _setDimensions);
                  __privateAdd(this, _renderAnnotationLayer);
                  __privateAdd(this, _renderAnnotationEditorLayer);
                  __privateAdd(this, _renderXfaLayer);
                  __privateAdd(this, _renderTextLayer);
                  __privateAdd(this, _renderStructTreeLayer);
                  __privateAdd(this, _buildXfaTextContentItems);
                  __privateAdd(this, _finishRenderTask);
                  __privateAdd(this, _annotationMode, _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  __privateAdd(this, _hasRestrictedScaling, false);
                  __privateAdd(this, _layerProperties, null);
                  __privateAdd(this, _loadingId, null);
                  __privateAdd(this, _previousRotation, null);
                  __privateAdd(this, _renderError, null);
                  __privateAdd(this, _renderingState, _ui_utils.RenderingStates.INITIAL);
                  __privateAdd(this, _textLayerMode, _ui_utils.TextLayerMode.ENABLE);
                  __privateAdd(this, _useThumbnailCanvas, {
                    directDrawing: true,
                    initialOptionalContent: true,
                    regularAnnotations: true
                  });
                  __privateAdd(this, _viewportMap, /* @__PURE__ */ new WeakMap());
                  var _a;
                  const container = options.container;
                  const defaultViewport = options.defaultViewport;
                  this.id = options.id;
                  this.renderingId = "page" + this.id;
                  __privateSet(this, _layerProperties, options.layerProperties || DEFAULT_LAYER_PROPERTIES);
                  this.pdfPage = null;
                  this.pageLabel = null;
                  this.rotation = 0;
                  this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
                  this.viewport = defaultViewport;
                  this.pdfPageRotate = defaultViewport.rotation;
                  this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
                  __privateSet(this, _textLayerMode, options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE);
                  __privateSet(this, _annotationMode, options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  this.imageResourcesPath = options.imageResourcesPath || "";
                  this.isOffscreenCanvasSupported = options.isOffscreenCanvasSupported ?? true;
                  this.maxCanvasPixels = options.maxCanvasPixels ?? MAX_CANVAS_PIXELS;
                  this.pageColors = options.pageColors || null;
                  this.eventBus = options.eventBus;
                  this.renderingQueue = options.renderingQueue;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  this.renderTask = null;
                  this.resume = null;
                  this._isStandalone = !((_a = this.renderingQueue) == null ? void 0 : _a.hasViewer());
                  this._container = container;
                  if (options.useOnlyCssZoom) {
                    console.error("useOnlyCssZoom was removed, please use `maxCanvasPixels = 0` instead.");
                    this.maxCanvasPixels = 0;
                  }
                  this._annotationCanvasMap = null;
                  this.annotationLayer = null;
                  this.annotationEditorLayer = null;
                  this.textLayer = null;
                  this.zoomLayer = null;
                  this.xfaLayer = null;
                  this.structTreeLayer = null;
                  const div = document.createElement("div");
                  div.className = "page";
                  div.setAttribute("data-page-number", this.id);
                  div.setAttribute("role", "region");
                  this.l10n.get("page_landmark", {
                    page: this.id
                  }).then((msg) => {
                    div.setAttribute("aria-label", msg);
                  });
                  this.div = div;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this);
                  container == null ? void 0 : container.append(div);
                  if (this._isStandalone) {
                    container == null ? void 0 : container.style.setProperty("--scale-factor", this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS);
                    const {
                      optionalContentConfigPromise
                    } = options;
                    if (optionalContentConfigPromise) {
                      optionalContentConfigPromise.then((optionalContentConfig) => {
                        if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
                          return;
                        }
                        __privateGet(this, _useThumbnailCanvas).initialOptionalContent = optionalContentConfig.hasInitialVisibility;
                      });
                    }
                  }
                }
                get renderingState() {
                  return __privateGet(this, _renderingState);
                }
                set renderingState(state) {
                  if (state === __privateGet(this, _renderingState)) {
                    return;
                  }
                  __privateSet(this, _renderingState, state);
                  if (__privateGet(this, _loadingId)) {
                    clearTimeout(__privateGet(this, _loadingId));
                    __privateSet(this, _loadingId, null);
                  }
                  switch (state) {
                    case _ui_utils.RenderingStates.PAUSED:
                      this.div.classList.remove("loading");
                      break;
                    case _ui_utils.RenderingStates.RUNNING:
                      this.div.classList.add("loadingIcon");
                      __privateSet(this, _loadingId, setTimeout(() => {
                        this.div.classList.add("loading");
                        __privateSet(this, _loadingId, null);
                      }, 0));
                      break;
                    case _ui_utils.RenderingStates.INITIAL:
                    case _ui_utils.RenderingStates.FINISHED:
                      this.div.classList.remove("loadingIcon", "loading");
                      break;
                  }
                }
                setPdfPage(pdfPage) {
                  var _a, _b, _c;
                  if (this._isStandalone && (((_a = this.pageColors) == null ? void 0 : _a.foreground) === "CanvasText" || ((_b = this.pageColors) == null ? void 0 : _b.background) === "Canvas")) {
                    (_c = this._container) == null ? void 0 : _c.style.setProperty("--hcm-highligh-filter", pdfPage.filterFactory.addHighlightHCMFilter("CanvasText", "Canvas", "HighlightText", "Highlight"));
                  }
                  this.pdfPage = pdfPage;
                  this.pdfPageRotate = pdfPage.rotate;
                  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                  this.viewport = pdfPage.getViewport({
                    scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: totalRotation
                  });
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this);
                  this.reset();
                }
                destroy() {
                  var _a;
                  this.reset();
                  (_a = this.pdfPage) == null ? void 0 : _a.cleanup();
                }
                get _textHighlighter() {
                  return (0, _pdfjsLib.shadow)(this, "_textHighlighter", new _text_highlighter.TextHighlighter({
                    pageIndex: this.id - 1,
                    eventBus: this.eventBus,
                    findController: __privateGet(this, _layerProperties).call(this).findController
                  }));
                }
                _resetZoomLayer(removeFromDOM = false) {
                  if (!this.zoomLayer) {
                    return;
                  }
                  const zoomLayerCanvas = this.zoomLayer.firstChild;
                  __privateGet(this, _viewportMap).delete(zoomLayerCanvas);
                  zoomLayerCanvas.width = 0;
                  zoomLayerCanvas.height = 0;
                  if (removeFromDOM) {
                    this.zoomLayer.remove();
                  }
                  this.zoomLayer = null;
                }
                reset({
                  keepZoomLayer = false,
                  keepAnnotationLayer = false,
                  keepAnnotationEditorLayer = false,
                  keepXfaLayer = false,
                  keepTextLayer = false
                } = {}) {
                  var _a, _b, _c, _d, _e;
                  this.cancelRendering({
                    keepAnnotationLayer,
                    keepAnnotationEditorLayer,
                    keepXfaLayer,
                    keepTextLayer
                  });
                  this.renderingState = _ui_utils.RenderingStates.INITIAL;
                  const div = this.div;
                  const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && ((_a = this.annotationLayer) == null ? void 0 : _a.div) || null, annotationEditorLayerNode = keepAnnotationEditorLayer && ((_b = this.annotationEditorLayer) == null ? void 0 : _b.div) || null, xfaLayerNode = keepXfaLayer && ((_c = this.xfaLayer) == null ? void 0 : _c.div) || null, textLayerNode = keepTextLayer && ((_d = this.textLayer) == null ? void 0 : _d.div) || null;
                  for (let i = childNodes.length - 1; i >= 0; i--) {
                    const node = childNodes[i];
                    switch (node) {
                      case zoomLayerNode:
                      case annotationLayerNode:
                      case annotationEditorLayerNode:
                      case xfaLayerNode:
                      case textLayerNode:
                        continue;
                    }
                    node.remove();
                  }
                  div.removeAttribute("data-loaded");
                  if (annotationLayerNode) {
                    this.annotationLayer.hide();
                  }
                  if (annotationEditorLayerNode) {
                    this.annotationEditorLayer.hide();
                  }
                  if (xfaLayerNode) {
                    this.xfaLayer.hide();
                  }
                  if (textLayerNode) {
                    this.textLayer.hide();
                  }
                  (_e = this.structTreeLayer) == null ? void 0 : _e.hide();
                  if (!zoomLayerNode) {
                    if (this.canvas) {
                      __privateGet(this, _viewportMap).delete(this.canvas);
                      this.canvas.width = 0;
                      this.canvas.height = 0;
                      delete this.canvas;
                    }
                    this._resetZoomLayer();
                  }
                }
                update({
                  scale = 0,
                  rotation = null,
                  optionalContentConfigPromise = null,
                  drawingDelay = -1
                }) {
                  var _a;
                  this.scale = scale || this.scale;
                  if (typeof rotation === "number") {
                    this.rotation = rotation;
                  }
                  if (optionalContentConfigPromise instanceof Promise) {
                    this._optionalContentConfigPromise = optionalContentConfigPromise;
                    optionalContentConfigPromise.then((optionalContentConfig) => {
                      if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
                        return;
                      }
                      __privateGet(this, _useThumbnailCanvas).initialOptionalContent = optionalContentConfig.hasInitialVisibility;
                    });
                  }
                  __privateGet(this, _useThumbnailCanvas).directDrawing = true;
                  const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                  this.viewport = this.viewport.clone({
                    scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                    rotation: totalRotation
                  });
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this);
                  if (this._isStandalone) {
                    (_a = this._container) == null ? void 0 : _a.style.setProperty("--scale-factor", this.viewport.scale);
                  }
                  if (this.canvas) {
                    let onlyCssZoom = false;
                    if (__privateGet(this, _hasRestrictedScaling)) {
                      if (this.maxCanvasPixels === 0) {
                        onlyCssZoom = true;
                      } else if (this.maxCanvasPixels > 0) {
                        const {
                          width,
                          height
                        } = this.viewport;
                        const {
                          sx,
                          sy
                        } = this.outputScale;
                        onlyCssZoom = (Math.floor(width) * sx | 0) * (Math.floor(height) * sy | 0) > this.maxCanvasPixels;
                      }
                    }
                    const postponeDrawing = !onlyCssZoom && drawingDelay >= 0 && drawingDelay < 1e3;
                    if (postponeDrawing || onlyCssZoom) {
                      if (postponeDrawing && this.renderingState !== _ui_utils.RenderingStates.FINISHED) {
                        this.cancelRendering({
                          keepZoomLayer: true,
                          keepAnnotationLayer: true,
                          keepAnnotationEditorLayer: true,
                          keepXfaLayer: true,
                          keepTextLayer: true,
                          cancelExtraDelay: drawingDelay
                        });
                        this.renderingState = _ui_utils.RenderingStates.FINISHED;
                        __privateGet(this, _useThumbnailCanvas).directDrawing = false;
                      }
                      this.cssTransform({
                        target: this.canvas,
                        redrawAnnotationLayer: true,
                        redrawAnnotationEditorLayer: true,
                        redrawXfaLayer: true,
                        redrawTextLayer: !postponeDrawing,
                        hideTextLayer: postponeDrawing
                      });
                      if (postponeDrawing) {
                        return;
                      }
                      this.eventBus.dispatch("pagerendered", {
                        source: this,
                        pageNumber: this.id,
                        cssTransform: true,
                        timestamp: performance.now(),
                        error: __privateGet(this, _renderError)
                      });
                      return;
                    }
                    if (!this.zoomLayer && !this.canvas.hidden) {
                      this.zoomLayer = this.canvas.parentNode;
                      this.zoomLayer.style.position = "absolute";
                    }
                  }
                  if (this.zoomLayer) {
                    this.cssTransform({
                      target: this.zoomLayer.firstChild
                    });
                  }
                  this.reset({
                    keepZoomLayer: true,
                    keepAnnotationLayer: true,
                    keepAnnotationEditorLayer: true,
                    keepXfaLayer: true,
                    keepTextLayer: true
                  });
                }
                cancelRendering({
                  keepAnnotationLayer = false,
                  keepAnnotationEditorLayer = false,
                  keepXfaLayer = false,
                  keepTextLayer = false,
                  cancelExtraDelay = 0
                } = {}) {
                  var _a;
                  if (this.renderTask) {
                    this.renderTask.cancel(cancelExtraDelay);
                    this.renderTask = null;
                  }
                  this.resume = null;
                  if (this.textLayer && (!keepTextLayer || !this.textLayer.div)) {
                    this.textLayer.cancel();
                    this.textLayer = null;
                  }
                  if (this.structTreeLayer && !this.textLayer) {
                    this.structTreeLayer = null;
                  }
                  if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
                    this.annotationLayer.cancel();
                    this.annotationLayer = null;
                    this._annotationCanvasMap = null;
                  }
                  if (this.annotationEditorLayer && (!keepAnnotationEditorLayer || !this.annotationEditorLayer.div)) {
                    this.annotationEditorLayer.cancel();
                    this.annotationEditorLayer = null;
                  }
                  if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
                    this.xfaLayer.cancel();
                    this.xfaLayer = null;
                    (_a = this._textHighlighter) == null ? void 0 : _a.disable();
                  }
                }
                cssTransform({
                  target,
                  redrawAnnotationLayer = false,
                  redrawAnnotationEditorLayer = false,
                  redrawXfaLayer = false,
                  redrawTextLayer = false,
                  hideTextLayer = false
                }) {
                  var _a;
                  if (!target.hasAttribute("zooming")) {
                    target.setAttribute("zooming", true);
                    const {
                      style
                    } = target;
                    style.width = style.height = "";
                  }
                  const originalViewport = __privateGet(this, _viewportMap).get(target);
                  if (this.viewport !== originalViewport) {
                    const relativeRotation = this.viewport.rotation - originalViewport.rotation;
                    const absRotation = Math.abs(relativeRotation);
                    let scaleX = 1, scaleY = 1;
                    if (absRotation === 90 || absRotation === 270) {
                      const {
                        width,
                        height
                      } = this.viewport;
                      scaleX = height / width;
                      scaleY = width / height;
                    }
                    target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;
                  }
                  if (redrawAnnotationLayer && this.annotationLayer) {
                    __privateMethod(this, _renderAnnotationLayer, renderAnnotationLayer_fn).call(this);
                  }
                  if (redrawAnnotationEditorLayer && this.annotationEditorLayer) {
                    __privateMethod(this, _renderAnnotationEditorLayer, renderAnnotationEditorLayer_fn).call(this);
                  }
                  if (redrawXfaLayer && this.xfaLayer) {
                    __privateMethod(this, _renderXfaLayer, renderXfaLayer_fn).call(this);
                  }
                  if (this.textLayer) {
                    if (hideTextLayer) {
                      this.textLayer.hide();
                      (_a = this.structTreeLayer) == null ? void 0 : _a.hide();
                    } else if (redrawTextLayer) {
                      __privateMethod(this, _renderTextLayer, renderTextLayer_fn).call(this);
                    }
                  }
                }
                get width() {
                  return this.viewport.width;
                }
                get height() {
                  return this.viewport.height;
                }
                getPagePoint(x, y) {
                  return this.viewport.convertToPdfPoint(x, y);
                }
                async draw() {
                  if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) {
                    console.error("Must be in new state before drawing");
                    this.reset();
                  }
                  const {
                    div,
                    l10n,
                    pageColors,
                    pdfPage,
                    viewport
                  } = this;
                  if (!pdfPage) {
                    this.renderingState = _ui_utils.RenderingStates.FINISHED;
                    throw new Error("pdfPage is not loaded");
                  }
                  this.renderingState = _ui_utils.RenderingStates.RUNNING;
                  const canvasWrapper = document.createElement("div");
                  canvasWrapper.classList.add("canvasWrapper");
                  div.append(canvasWrapper);
                  if (!this.textLayer && __privateGet(this, _textLayerMode) !== _ui_utils.TextLayerMode.DISABLE && !pdfPage.isPureXfa) {
                    this._accessibilityManager || (this._accessibilityManager = new _text_accessibility.TextAccessibilityManager());
                    this.textLayer = new _text_layer_builder.TextLayerBuilder({
                      highlighter: this._textHighlighter,
                      accessibilityManager: this._accessibilityManager,
                      isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                      enablePermissions: __privateGet(this, _textLayerMode) === _ui_utils.TextLayerMode.ENABLE_PERMISSIONS
                    });
                    div.append(this.textLayer.div);
                  }
                  if (!this.annotationLayer && __privateGet(this, _annotationMode) !== _pdfjsLib.AnnotationMode.DISABLE) {
                    const {
                      annotationStorage,
                      downloadManager,
                      enableScripting,
                      fieldObjectsPromise,
                      hasJSActionsPromise,
                      linkService
                    } = __privateGet(this, _layerProperties).call(this);
                    this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map());
                    this.annotationLayer = new _annotation_layer_builder.AnnotationLayerBuilder({
                      pageDiv: div,
                      pdfPage,
                      annotationStorage,
                      imageResourcesPath: this.imageResourcesPath,
                      renderForms: __privateGet(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS,
                      linkService,
                      downloadManager,
                      l10n,
                      enableScripting,
                      hasJSActionsPromise,
                      fieldObjectsPromise,
                      annotationCanvasMap: this._annotationCanvasMap,
                      accessibilityManager: this._accessibilityManager
                    });
                  }
                  const renderContinueCallback = (cont) => {
                    showCanvas == null ? void 0 : showCanvas(false);
                    if (this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
                      this.renderingState = _ui_utils.RenderingStates.PAUSED;
                      this.resume = () => {
                        this.renderingState = _ui_utils.RenderingStates.RUNNING;
                        cont();
                      };
                      return;
                    }
                    cont();
                  };
                  const {
                    width,
                    height
                  } = viewport;
                  const canvas = document.createElement("canvas");
                  canvas.setAttribute("role", "presentation");
                  canvas.hidden = true;
                  const hasHCM = !!((pageColors == null ? void 0 : pageColors.background) && (pageColors == null ? void 0 : pageColors.foreground));
                  let showCanvas = (isLastShow) => {
                    if (!hasHCM || isLastShow) {
                      canvas.hidden = false;
                      showCanvas = null;
                    }
                  };
                  canvasWrapper.append(canvas);
                  this.canvas = canvas;
                  const ctx = canvas.getContext("2d", {
                    alpha: false
                  });
                  const outputScale = this.outputScale = new _ui_utils.OutputScale();
                  if (this.maxCanvasPixels === 0) {
                    const invScale = 1 / this.scale;
                    outputScale.sx *= invScale;
                    outputScale.sy *= invScale;
                    __privateSet(this, _hasRestrictedScaling, true);
                  } else if (this.maxCanvasPixels > 0) {
                    const pixelsInViewport = width * height;
                    const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
                    if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
                      outputScale.sx = maxScale;
                      outputScale.sy = maxScale;
                      __privateSet(this, _hasRestrictedScaling, true);
                    } else {
                      __privateSet(this, _hasRestrictedScaling, false);
                    }
                  }
                  const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
                  const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
                  canvas.width = (0, _ui_utils.roundToDivide)(width * outputScale.sx, sfx[0]);
                  canvas.height = (0, _ui_utils.roundToDivide)(height * outputScale.sy, sfy[0]);
                  const {
                    style
                  } = canvas;
                  style.width = (0, _ui_utils.roundToDivide)(width, sfx[1]) + "px";
                  style.height = (0, _ui_utils.roundToDivide)(height, sfy[1]) + "px";
                  __privateGet(this, _viewportMap).set(canvas, viewport);
                  const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null;
                  const renderContext = {
                    canvasContext: ctx,
                    transform,
                    viewport,
                    annotationMode: __privateGet(this, _annotationMode),
                    optionalContentConfigPromise: this._optionalContentConfigPromise,
                    annotationCanvasMap: this._annotationCanvasMap,
                    pageColors
                  };
                  const renderTask = this.renderTask = this.pdfPage.render(renderContext);
                  renderTask.onContinue = renderContinueCallback;
                  const resultPromise = renderTask.promise.then(async () => {
                    var _a;
                    showCanvas == null ? void 0 : showCanvas(true);
                    await __privateMethod(this, _finishRenderTask, finishRenderTask_fn).call(this, renderTask);
                    __privateMethod(this, _renderTextLayer, renderTextLayer_fn).call(this);
                    if (this.annotationLayer) {
                      await __privateMethod(this, _renderAnnotationLayer, renderAnnotationLayer_fn).call(this);
                    }
                    if (!this.annotationEditorLayer) {
                      const {
                        annotationEditorUIManager
                      } = __privateGet(this, _layerProperties).call(this);
                      if (!annotationEditorUIManager) {
                        return;
                      }
                      this.annotationEditorLayer = new _annotation_editor_layer_builder.AnnotationEditorLayerBuilder({
                        uiManager: annotationEditorUIManager,
                        pageDiv: div,
                        pdfPage,
                        l10n,
                        accessibilityManager: this._accessibilityManager,
                        annotationLayer: (_a = this.annotationLayer) == null ? void 0 : _a.annotationLayer
                      });
                    }
                    __privateMethod(this, _renderAnnotationEditorLayer, renderAnnotationEditorLayer_fn).call(this);
                  }, (error) => {
                    if (!(error instanceof _pdfjsLib.RenderingCancelledException)) {
                      showCanvas == null ? void 0 : showCanvas(true);
                    }
                    return __privateMethod(this, _finishRenderTask, finishRenderTask_fn).call(this, renderTask, error);
                  });
                  if (pdfPage.isPureXfa) {
                    if (!this.xfaLayer) {
                      const {
                        annotationStorage,
                        linkService
                      } = __privateGet(this, _layerProperties).call(this);
                      this.xfaLayer = new _xfa_layer_builder.XfaLayerBuilder({
                        pageDiv: div,
                        pdfPage,
                        annotationStorage,
                        linkService
                      });
                    } else if (this.xfaLayer.div) {
                      div.append(this.xfaLayer.div);
                    }
                    __privateMethod(this, _renderXfaLayer, renderXfaLayer_fn).call(this);
                  }
                  div.setAttribute("data-loaded", true);
                  this.eventBus.dispatch("pagerender", {
                    source: this,
                    pageNumber: this.id
                  });
                  return resultPromise;
                }
                setPageLabel(label) {
                  this.pageLabel = typeof label === "string" ? label : null;
                  if (this.pageLabel !== null) {
                    this.div.setAttribute("data-page-label", this.pageLabel);
                  } else {
                    this.div.removeAttribute("data-page-label");
                  }
                }
                get thumbnailCanvas() {
                  const {
                    directDrawing,
                    initialOptionalContent,
                    regularAnnotations
                  } = __privateGet(this, _useThumbnailCanvas);
                  return directDrawing && initialOptionalContent && regularAnnotations ? this.canvas : null;
                }
              }
              _annotationMode = new WeakMap();
              _hasRestrictedScaling = new WeakMap();
              _layerProperties = new WeakMap();
              _loadingId = new WeakMap();
              _previousRotation = new WeakMap();
              _renderError = new WeakMap();
              _renderingState = new WeakMap();
              _textLayerMode = new WeakMap();
              _useThumbnailCanvas = new WeakMap();
              _viewportMap = new WeakMap();
              _setDimensions = new WeakSet();
              setDimensions_fn = function() {
                const {
                  viewport
                } = this;
                if (this.pdfPage) {
                  if (__privateGet(this, _previousRotation) === viewport.rotation) {
                    return;
                  }
                  __privateSet(this, _previousRotation, viewport.rotation);
                }
                (0, _pdfjsLib.setLayerDimensions)(this.div, viewport, true, false);
              };
              _renderAnnotationLayer = new WeakSet();
              renderAnnotationLayer_fn = async function() {
                let error = null;
                try {
                  await this.annotationLayer.render(this.viewport, "display");
                } catch (ex) {
                  console.error(`#renderAnnotationLayer: "${ex}".`);
                  error = ex;
                } finally {
                  this.eventBus.dispatch("annotationlayerrendered", {
                    source: this,
                    pageNumber: this.id,
                    error
                  });
                }
              };
              _renderAnnotationEditorLayer = new WeakSet();
              renderAnnotationEditorLayer_fn = async function() {
                let error = null;
                try {
                  await this.annotationEditorLayer.render(this.viewport, "display");
                } catch (ex) {
                  console.error(`#renderAnnotationEditorLayer: "${ex}".`);
                  error = ex;
                } finally {
                  this.eventBus.dispatch("annotationeditorlayerrendered", {
                    source: this,
                    pageNumber: this.id,
                    error
                  });
                }
              };
              _renderXfaLayer = new WeakSet();
              renderXfaLayer_fn = async function() {
                let error = null;
                try {
                  const result = await this.xfaLayer.render(this.viewport, "display");
                  if ((result == null ? void 0 : result.textDivs) && this._textHighlighter) {
                    __privateMethod(this, _buildXfaTextContentItems, buildXfaTextContentItems_fn).call(this, result.textDivs);
                  }
                } catch (ex) {
                  console.error(`#renderXfaLayer: "${ex}".`);
                  error = ex;
                } finally {
                  this.eventBus.dispatch("xfalayerrendered", {
                    source: this,
                    pageNumber: this.id,
                    error
                  });
                }
              };
              _renderTextLayer = new WeakSet();
              renderTextLayer_fn = async function() {
                const {
                  pdfPage,
                  textLayer,
                  viewport
                } = this;
                if (!textLayer) {
                  return;
                }
                let error = null;
                try {
                  if (!textLayer.renderingDone) {
                    const readableStream = pdfPage.streamTextContent({
                      includeMarkedContent: true,
                      disableNormalization: true
                    });
                    textLayer.setTextContentSource(readableStream);
                  }
                  await textLayer.render(viewport);
                } catch (ex) {
                  if (ex instanceof _pdfjsLib.AbortException) {
                    return;
                  }
                  console.error(`#renderTextLayer: "${ex}".`);
                  error = ex;
                }
                this.eventBus.dispatch("textlayerrendered", {
                  source: this,
                  pageNumber: this.id,
                  numTextDivs: textLayer.numTextDivs,
                  error
                });
                __privateMethod(this, _renderStructTreeLayer, renderStructTreeLayer_fn).call(this);
              };
              _renderStructTreeLayer = new WeakSet();
              renderStructTreeLayer_fn = async function() {
                var _a, _b, _c;
                if (!this.textLayer) {
                  return;
                }
                this.structTreeLayer || (this.structTreeLayer = new _struct_tree_layer_builder.StructTreeLayerBuilder());
                const tree = await (!this.structTreeLayer.renderingDone ? this.pdfPage.getStructTree() : null);
                const treeDom = (_a = this.structTreeLayer) == null ? void 0 : _a.render(tree);
                if (treeDom) {
                  (_b = this.canvas) == null ? void 0 : _b.append(treeDom);
                }
                (_c = this.structTreeLayer) == null ? void 0 : _c.show();
              };
              _buildXfaTextContentItems = new WeakSet();
              buildXfaTextContentItems_fn = async function(textDivs) {
                const text = await this.pdfPage.getTextContent();
                const items = [];
                for (const item of text.items) {
                  items.push(item.str);
                }
                this._textHighlighter.setTextMapping(textDivs, items);
                this._textHighlighter.enable();
              };
              _finishRenderTask = new WeakSet();
              finishRenderTask_fn = async function(renderTask, error = null) {
                if (renderTask === this.renderTask) {
                  this.renderTask = null;
                }
                if (error instanceof _pdfjsLib.RenderingCancelledException) {
                  __privateSet(this, _renderError, null);
                  return;
                }
                __privateSet(this, _renderError, error);
                this.renderingState = _ui_utils.RenderingStates.FINISHED;
                this._resetZoomLayer(true);
                __privateGet(this, _useThumbnailCanvas).regularAnnotations = !renderTask.separateAnnots;
                this.eventBus.dispatch("pagerendered", {
                  source: this,
                  pageNumber: this.id,
                  cssTransform: false,
                  timestamp: performance.now(),
                  error: __privateGet(this, _renderError)
                });
                if (error) {
                  throw error;
                }
              };
              exports2.PDFPageView = PDFPageView;
            },
            /* 14 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _annotationLayer, _uiManager;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _l10n_utils = __w_pdfjs_require__2(7);
              class AnnotationEditorLayerBuilder {
                constructor(options) {
                  __privateAdd(this, _annotationLayer, null);
                  __privateAdd(this, _uiManager, void 0);
                  this.pageDiv = options.pageDiv;
                  this.pdfPage = options.pdfPage;
                  this.accessibilityManager = options.accessibilityManager;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  this.annotationEditorLayer = null;
                  this.div = null;
                  this._cancelled = false;
                  __privateSet(this, _uiManager, options.uiManager);
                  __privateSet(this, _annotationLayer, options.annotationLayer || null);
                }
                async render(viewport, intent = "display") {
                  if (intent !== "display") {
                    return;
                  }
                  if (this._cancelled) {
                    return;
                  }
                  const clonedViewport = viewport.clone({
                    dontFlip: true
                  });
                  if (this.div) {
                    this.annotationEditorLayer.update({
                      viewport: clonedViewport
                    });
                    this.show();
                    return;
                  }
                  const div = this.div = document.createElement("div");
                  div.className = "annotationEditorLayer";
                  div.tabIndex = 0;
                  div.hidden = true;
                  this.pageDiv.append(div);
                  this.annotationEditorLayer = new _pdfjsLib.AnnotationEditorLayer({
                    uiManager: __privateGet(this, _uiManager),
                    div,
                    accessibilityManager: this.accessibilityManager,
                    pageIndex: this.pdfPage.pageNumber - 1,
                    l10n: this.l10n,
                    viewport: clonedViewport,
                    annotationLayer: __privateGet(this, _annotationLayer)
                  });
                  const parameters = {
                    viewport: clonedViewport,
                    div,
                    annotations: null,
                    intent
                  };
                  this.annotationEditorLayer.render(parameters);
                  this.show();
                }
                cancel() {
                  this._cancelled = true;
                  if (!this.div) {
                    return;
                  }
                  this.pageDiv = null;
                  this.annotationEditorLayer.destroy();
                  this.div.remove();
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
                show() {
                  if (!this.div || this.annotationEditorLayer.isEmpty) {
                    return;
                  }
                  this.div.hidden = false;
                }
              }
              _annotationLayer = new WeakMap();
              _uiManager = new WeakMap();
              exports2.AnnotationEditorLayerBuilder = AnnotationEditorLayerBuilder;
            },
            /* 15 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.compatibilityParams = exports2.OptionKind = exports2.AppOptions = void 0;
              const compatibilityParams = /* @__PURE__ */ Object.create(null);
              exports2.compatibilityParams = compatibilityParams;
              {
                const userAgent = navigator.userAgent || "";
                const platform = navigator.platform || "";
                const maxTouchPoints = navigator.maxTouchPoints || 1;
                const isAndroid = /Android/.test(userAgent);
                const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
                (function checkCanvasSizeLimitation() {
                  if (isIOS || isAndroid) {
                    compatibilityParams.maxCanvasPixels = 5242880;
                  }
                })();
              }
              const OptionKind = {
                VIEWER: 2,
                API: 4,
                WORKER: 8,
                PREFERENCE: 128
              };
              exports2.OptionKind = OptionKind;
              const defaultOptions = {
                annotationEditorMode: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                annotationMode: {
                  value: 2,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                cursorToolOnLoad: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                defaultZoomDelay: {
                  value: 400,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                defaultZoomValue: {
                  value: "",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                disableHistory: {
                  value: false,
                  kind: OptionKind.VIEWER
                },
                disablePageLabels: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enablePermissions: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enablePrintAutoRotate: {
                  value: true,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enableScripting: {
                  value: true,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                enableStampEditor: {
                  value: true,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                externalLinkRel: {
                  value: "noopener noreferrer nofollow",
                  kind: OptionKind.VIEWER
                },
                externalLinkTarget: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                historyUpdateUrl: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                ignoreDestinationZoom: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                imageResourcesPath: {
                  value: "./images/",
                  kind: OptionKind.VIEWER
                },
                maxCanvasPixels: {
                  value: 16777216,
                  kind: OptionKind.VIEWER
                },
                forcePageColors: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pageColorsBackground: {
                  value: "Canvas",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pageColorsForeground: {
                  value: "CanvasText",
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                pdfBugEnabled: {
                  value: false,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                printResolution: {
                  value: 150,
                  kind: OptionKind.VIEWER
                },
                sidebarViewOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                scrollModeOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                spreadModeOnLoad: {
                  value: -1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                textLayerMode: {
                  value: 1,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                viewerCssTheme: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                viewOnLoad: {
                  value: 0,
                  kind: OptionKind.VIEWER + OptionKind.PREFERENCE
                },
                cMapPacked: {
                  value: true,
                  kind: OptionKind.API
                },
                cMapUrl: {
                  value: "../web/cmaps/",
                  kind: OptionKind.API
                },
                disableAutoFetch: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableFontFace: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableRange: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                disableStream: {
                  value: false,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                docBaseUrl: {
                  value: "",
                  kind: OptionKind.API
                },
                enableXfa: {
                  value: true,
                  kind: OptionKind.API + OptionKind.PREFERENCE
                },
                fontExtraProperties: {
                  value: false,
                  kind: OptionKind.API
                },
                isEvalSupported: {
                  value: true,
                  kind: OptionKind.API
                },
                isOffscreenCanvasSupported: {
                  value: true,
                  kind: OptionKind.API
                },
                maxImageSize: {
                  value: -1,
                  kind: OptionKind.API
                },
                pdfBug: {
                  value: false,
                  kind: OptionKind.API
                },
                standardFontDataUrl: {
                  value: "../web/standard_fonts/",
                  kind: OptionKind.API
                },
                verbosity: {
                  value: 1,
                  kind: OptionKind.API
                },
                workerPort: {
                  value: null,
                  kind: OptionKind.WORKER
                },
                workerSrc: {
                  value: "../build/pdf.worker.js",
                  kind: OptionKind.WORKER
                }
              };
              {
                defaultOptions.defaultUrl = {
                  value: "compressed.tracemonkey-pldi-09.pdf",
                  kind: OptionKind.VIEWER
                };
                defaultOptions.disablePreferences = {
                  value: false,
                  kind: OptionKind.VIEWER
                };
                defaultOptions.locale = {
                  value: navigator.language || "en-US",
                  kind: OptionKind.VIEWER
                };
                defaultOptions.sandboxBundleSrc = {
                  value: "../build/pdf.sandbox.js",
                  kind: OptionKind.VIEWER
                };
              }
              const userOptions = /* @__PURE__ */ Object.create(null);
              class AppOptions {
                constructor() {
                  throw new Error("Cannot initialize AppOptions.");
                }
                static get(name) {
                  const userOption = userOptions[name];
                  if (userOption !== void 0) {
                    return userOption;
                  }
                  const defaultOption = defaultOptions[name];
                  if (defaultOption !== void 0) {
                    return compatibilityParams[name] ?? defaultOption.value;
                  }
                  return void 0;
                }
                static getAll(kind = null) {
                  const options = /* @__PURE__ */ Object.create(null);
                  for (const name in defaultOptions) {
                    const defaultOption = defaultOptions[name];
                    if (kind) {
                      if ((kind & defaultOption.kind) === 0) {
                        continue;
                      }
                      if (kind === OptionKind.PREFERENCE) {
                        const value = defaultOption.value, valueType = typeof value;
                        if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
                          options[name] = value;
                          continue;
                        }
                        throw new Error(`Invalid type for preference: ${name}`);
                      }
                    }
                    const userOption = userOptions[name];
                    options[name] = userOption !== void 0 ? userOption : compatibilityParams[name] ?? defaultOption.value;
                  }
                  return options;
                }
                static set(name, value) {
                  userOptions[name] = value;
                }
                static setAll(options) {
                  for (const name in options) {
                    userOptions[name] = options[name];
                  }
                }
                static remove(name) {
                  delete userOptions[name];
                }
              }
              exports2.AppOptions = AppOptions;
              {
                AppOptions._hasUserOptions = function() {
                  return Object.keys(userOptions).length > 0;
                };
              }
            },
            /* 16 */
            /***/
            (__unused_webpack_module, exports2) => {
              var _treeDom, _setAttributes, setAttributes_fn, _walk, walk_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StructTreeLayerBuilder = void 0;
              const PDF_ROLE_TO_HTML_ROLE = {
                Document: null,
                DocumentFragment: null,
                Part: "group",
                Sect: "group",
                Div: "group",
                Aside: "note",
                NonStruct: "none",
                P: null,
                H: "heading",
                Title: null,
                FENote: "note",
                Sub: "group",
                Lbl: null,
                Span: null,
                Em: null,
                Strong: null,
                Link: "link",
                Annot: "note",
                Form: "form",
                Ruby: null,
                RB: null,
                RT: null,
                RP: null,
                Warichu: null,
                WT: null,
                WP: null,
                L: "list",
                LI: "listitem",
                LBody: null,
                Table: "table",
                TR: "row",
                TH: "columnheader",
                TD: "cell",
                THead: "columnheader",
                TBody: null,
                TFoot: null,
                Caption: null,
                Figure: "figure",
                Formula: null,
                Artifact: null
              };
              const HEADING_PATTERN = /^H(\d+)$/;
              class StructTreeLayerBuilder {
                constructor() {
                  __privateAdd(this, _setAttributes);
                  __privateAdd(this, _walk);
                  __privateAdd(this, _treeDom, void 0);
                }
                get renderingDone() {
                  return __privateGet(this, _treeDom) !== void 0;
                }
                render(structTree) {
                  if (__privateGet(this, _treeDom) !== void 0) {
                    return __privateGet(this, _treeDom);
                  }
                  const treeDom = __privateMethod(this, _walk, walk_fn).call(this, structTree);
                  treeDom == null ? void 0 : treeDom.classList.add("structTree");
                  return __privateSet(this, _treeDom, treeDom);
                }
                hide() {
                  if (__privateGet(this, _treeDom) && !__privateGet(this, _treeDom).hidden) {
                    __privateGet(this, _treeDom).hidden = true;
                  }
                }
                show() {
                  var _a;
                  if ((_a = __privateGet(this, _treeDom)) == null ? void 0 : _a.hidden) {
                    __privateGet(this, _treeDom).hidden = false;
                  }
                }
              }
              _treeDom = new WeakMap();
              _setAttributes = new WeakSet();
              setAttributes_fn = function(structElement, htmlElement) {
                if (structElement.alt !== void 0) {
                  htmlElement.setAttribute("aria-label", structElement.alt);
                }
                if (structElement.id !== void 0) {
                  htmlElement.setAttribute("aria-owns", structElement.id);
                }
                if (structElement.lang !== void 0) {
                  htmlElement.setAttribute("lang", structElement.lang);
                }
              };
              _walk = new WeakSet();
              walk_fn = function(node) {
                if (!node) {
                  return null;
                }
                const element = document.createElement("span");
                if ("role" in node) {
                  const {
                    role
                  } = node;
                  const match = role.match(HEADING_PATTERN);
                  if (match) {
                    element.setAttribute("role", "heading");
                    element.setAttribute("aria-level", match[1]);
                  } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
                    element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
                  }
                }
                __privateMethod(this, _setAttributes, setAttributes_fn).call(this, node, element);
                if (node.children) {
                  if (node.children.length === 1 && "id" in node.children[0]) {
                    __privateMethod(this, _setAttributes, setAttributes_fn).call(this, node.children[0], element);
                  } else {
                    for (const kid of node.children) {
                      element.append(__privateMethod(this, _walk, walk_fn).call(this, kid));
                    }
                  }
                }
                return element;
              };
              exports2.StructTreeLayerBuilder = StructTreeLayerBuilder;
            },
            /* 17 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _enabled, _textChildren, _textNodes, _waitingElements, _compareElementPositions, compareElementPositions_fn, _addIdToAriaOwns, addIdToAriaOwns_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextAccessibilityManager = void 0;
              var _ui_utils = __w_pdfjs_require__2(2);
              const _TextAccessibilityManager = class _TextAccessibilityManager {
                constructor() {
                  __privateAdd(this, _addIdToAriaOwns);
                  __privateAdd(this, _enabled, false);
                  __privateAdd(this, _textChildren, null);
                  __privateAdd(this, _textNodes, /* @__PURE__ */ new Map());
                  __privateAdd(this, _waitingElements, /* @__PURE__ */ new Map());
                }
                setTextMapping(textDivs) {
                  __privateSet(this, _textChildren, textDivs);
                }
                enable() {
                  if (__privateGet(this, _enabled)) {
                    throw new Error("TextAccessibilityManager is already enabled.");
                  }
                  if (!__privateGet(this, _textChildren)) {
                    throw new Error("Text divs and strings have not been set.");
                  }
                  __privateSet(this, _enabled, true);
                  __privateSet(this, _textChildren, __privateGet(this, _textChildren).slice());
                  __privateGet(this, _textChildren).sort(__privateMethod(_TextAccessibilityManager, _compareElementPositions, compareElementPositions_fn));
                  if (__privateGet(this, _textNodes).size > 0) {
                    const textChildren = __privateGet(this, _textChildren);
                    for (const [id, nodeIndex] of __privateGet(this, _textNodes)) {
                      const element = document.getElementById(id);
                      if (!element) {
                        __privateGet(this, _textNodes).delete(id);
                        continue;
                      }
                      __privateMethod(this, _addIdToAriaOwns, addIdToAriaOwns_fn).call(this, id, textChildren[nodeIndex]);
                    }
                  }
                  for (const [element, isRemovable] of __privateGet(this, _waitingElements)) {
                    this.addPointerInTextLayer(element, isRemovable);
                  }
                  __privateGet(this, _waitingElements).clear();
                }
                disable() {
                  if (!__privateGet(this, _enabled)) {
                    return;
                  }
                  __privateGet(this, _waitingElements).clear();
                  __privateSet(this, _textChildren, null);
                  __privateSet(this, _enabled, false);
                }
                removePointerInTextLayer(element) {
                  if (!__privateGet(this, _enabled)) {
                    __privateGet(this, _waitingElements).delete(element);
                    return;
                  }
                  const children = __privateGet(this, _textChildren);
                  if (!children || children.length === 0) {
                    return;
                  }
                  const {
                    id
                  } = element;
                  const nodeIndex = __privateGet(this, _textNodes).get(id);
                  if (nodeIndex === void 0) {
                    return;
                  }
                  const node = children[nodeIndex];
                  __privateGet(this, _textNodes).delete(id);
                  let owns = node.getAttribute("aria-owns");
                  if (owns == null ? void 0 : owns.includes(id)) {
                    owns = owns.split(" ").filter((x) => x !== id).join(" ");
                    if (owns) {
                      node.setAttribute("aria-owns", owns);
                    } else {
                      node.removeAttribute("aria-owns");
                      node.setAttribute("role", "presentation");
                    }
                  }
                }
                addPointerInTextLayer(element, isRemovable) {
                  const {
                    id
                  } = element;
                  if (!id) {
                    return;
                  }
                  if (!__privateGet(this, _enabled)) {
                    __privateGet(this, _waitingElements).set(element, isRemovable);
                    return;
                  }
                  if (isRemovable) {
                    this.removePointerInTextLayer(element);
                  }
                  const children = __privateGet(this, _textChildren);
                  if (!children || children.length === 0) {
                    return;
                  }
                  const index = (0, _ui_utils.binarySearchFirstItem)(children, (node) => {
                    var _a;
                    return __privateMethod(_a = _TextAccessibilityManager, _compareElementPositions, compareElementPositions_fn).call(_a, element, node) < 0;
                  });
                  const nodeIndex = Math.max(0, index - 1);
                  __privateMethod(this, _addIdToAriaOwns, addIdToAriaOwns_fn).call(this, id, children[nodeIndex]);
                  __privateGet(this, _textNodes).set(id, nodeIndex);
                }
                moveElementInDOM(container, element, contentElement, isRemovable) {
                  this.addPointerInTextLayer(contentElement, isRemovable);
                  if (!container.hasChildNodes()) {
                    container.append(element);
                    return;
                  }
                  const children = Array.from(container.childNodes).filter((node) => node !== element);
                  if (children.length === 0) {
                    return;
                  }
                  const elementToCompare = contentElement || element;
                  const index = (0, _ui_utils.binarySearchFirstItem)(children, (node) => {
                    var _a;
                    return __privateMethod(_a = _TextAccessibilityManager, _compareElementPositions, compareElementPositions_fn).call(_a, elementToCompare, node) < 0;
                  });
                  if (index === 0) {
                    children[0].before(element);
                  } else {
                    children[index - 1].after(element);
                  }
                }
              };
              _enabled = new WeakMap();
              _textChildren = new WeakMap();
              _textNodes = new WeakMap();
              _waitingElements = new WeakMap();
              _compareElementPositions = new WeakSet();
              compareElementPositions_fn = function(e1, e2) {
                const rect1 = e1.getBoundingClientRect();
                const rect2 = e2.getBoundingClientRect();
                if (rect1.width === 0 && rect1.height === 0) {
                  return 1;
                }
                if (rect2.width === 0 && rect2.height === 0) {
                  return -1;
                }
                const top1 = rect1.y;
                const bot1 = rect1.y + rect1.height;
                const mid1 = rect1.y + rect1.height / 2;
                const top2 = rect2.y;
                const bot2 = rect2.y + rect2.height;
                const mid2 = rect2.y + rect2.height / 2;
                if (mid1 <= top2 && mid2 >= bot1) {
                  return -1;
                }
                if (mid2 <= top1 && mid1 >= bot2) {
                  return 1;
                }
                const centerX1 = rect1.x + rect1.width / 2;
                const centerX2 = rect2.x + rect2.width / 2;
                return centerX1 - centerX2;
              };
              _addIdToAriaOwns = new WeakSet();
              addIdToAriaOwns_fn = function(id, node) {
                const owns = node.getAttribute("aria-owns");
                if (!(owns == null ? void 0 : owns.includes(id))) {
                  node.setAttribute("aria-owns", owns ? `${owns} ${id}` : id);
                }
                node.removeAttribute("role");
              };
              __privateAdd(_TextAccessibilityManager, _compareElementPositions);
              let TextAccessibilityManager = _TextAccessibilityManager;
              exports2.TextAccessibilityManager = TextAccessibilityManager;
            },
            /* 18 */
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextHighlighter = void 0;
              class TextHighlighter {
                constructor({
                  findController,
                  eventBus,
                  pageIndex
                }) {
                  this.findController = findController;
                  this.matches = [];
                  this.eventBus = eventBus;
                  this.pageIdx = pageIndex;
                  this._onUpdateTextLayerMatches = null;
                  this.textDivs = null;
                  this.textContentItemsStr = null;
                  this.enabled = false;
                }
                setTextMapping(divs, texts) {
                  this.textDivs = divs;
                  this.textContentItemsStr = texts;
                }
                enable() {
                  if (!this.textDivs || !this.textContentItemsStr) {
                    throw new Error("Text divs and strings have not been set.");
                  }
                  if (this.enabled) {
                    throw new Error("TextHighlighter is already enabled.");
                  }
                  this.enabled = true;
                  if (!this._onUpdateTextLayerMatches) {
                    this._onUpdateTextLayerMatches = (evt) => {
                      if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
                        this._updateMatches();
                      }
                    };
                    this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
                  }
                  this._updateMatches();
                }
                disable() {
                  if (!this.enabled) {
                    return;
                  }
                  this.enabled = false;
                  if (this._onUpdateTextLayerMatches) {
                    this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);
                    this._onUpdateTextLayerMatches = null;
                  }
                  this._updateMatches(true);
                }
                _convertMatches(matches, matchesLength) {
                  if (!matches) {
                    return [];
                  }
                  const {
                    textContentItemsStr
                  } = this;
                  let i = 0, iIndex = 0;
                  const end = textContentItemsStr.length - 1;
                  const result = [];
                  for (let m = 0, mm = matches.length; m < mm; m++) {
                    let matchIdx = matches[m];
                    while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
                      iIndex += textContentItemsStr[i].length;
                      i++;
                    }
                    if (i === textContentItemsStr.length) {
                      console.error("Could not find a matching mapping");
                    }
                    const match = {
                      begin: {
                        divIdx: i,
                        offset: matchIdx - iIndex
                      }
                    };
                    matchIdx += matchesLength[m];
                    while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
                      iIndex += textContentItemsStr[i].length;
                      i++;
                    }
                    match.end = {
                      divIdx: i,
                      offset: matchIdx - iIndex
                    };
                    result.push(match);
                  }
                  return result;
                }
                _renderMatches(matches) {
                  if (matches.length === 0) {
                    return;
                  }
                  const {
                    findController,
                    pageIdx
                  } = this;
                  const {
                    textContentItemsStr,
                    textDivs
                  } = this;
                  const isSelectedPage = pageIdx === findController.selected.pageIdx;
                  const selectedMatchIdx = findController.selected.matchIdx;
                  const highlightAll = findController.state.highlightAll;
                  let prevEnd = null;
                  const infinity = {
                    divIdx: -1,
                    offset: void 0
                  };
                  function beginText(begin, className) {
                    const divIdx = begin.divIdx;
                    textDivs[divIdx].textContent = "";
                    return appendTextToDiv(divIdx, 0, begin.offset, className);
                  }
                  function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
                    let div = textDivs[divIdx];
                    if (div.nodeType === Node.TEXT_NODE) {
                      const span = document.createElement("span");
                      div.before(span);
                      span.append(div);
                      textDivs[divIdx] = span;
                      div = span;
                    }
                    const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
                    const node = document.createTextNode(content);
                    if (className) {
                      const span = document.createElement("span");
                      span.className = `${className} appended`;
                      span.append(node);
                      div.append(span);
                      return className.includes("selected") ? span.offsetLeft : 0;
                    }
                    div.append(node);
                    return 0;
                  }
                  let i0 = selectedMatchIdx, i1 = i0 + 1;
                  if (highlightAll) {
                    i0 = 0;
                    i1 = matches.length;
                  } else if (!isSelectedPage) {
                    return;
                  }
                  let lastDivIdx = -1;
                  let lastOffset = -1;
                  for (let i = i0; i < i1; i++) {
                    const match = matches[i];
                    const begin = match.begin;
                    if (begin.divIdx === lastDivIdx && begin.offset === lastOffset) {
                      continue;
                    }
                    lastDivIdx = begin.divIdx;
                    lastOffset = begin.offset;
                    const end = match.end;
                    const isSelected = isSelectedPage && i === selectedMatchIdx;
                    const highlightSuffix = isSelected ? " selected" : "";
                    let selectedLeft = 0;
                    if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
                      if (prevEnd !== null) {
                        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                      }
                      beginText(begin);
                    } else {
                      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
                    }
                    if (begin.divIdx === end.divIdx) {
                      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
                    } else {
                      selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
                      for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                        textDivs[n0].className = "highlight middle" + highlightSuffix;
                      }
                      beginText(end, "highlight end" + highlightSuffix);
                    }
                    prevEnd = end;
                    if (isSelected) {
                      findController.scrollMatchIntoView({
                        element: textDivs[begin.divIdx],
                        selectedLeft,
                        pageIndex: pageIdx,
                        matchIndex: selectedMatchIdx
                      });
                    }
                  }
                  if (prevEnd) {
                    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                  }
                }
                _updateMatches(reset = false) {
                  if (!this.enabled && !reset) {
                    return;
                  }
                  const {
                    findController,
                    matches,
                    pageIdx
                  } = this;
                  const {
                    textContentItemsStr,
                    textDivs
                  } = this;
                  let clearedUntilDivIdx = -1;
                  for (const match of matches) {
                    const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
                    for (let n = begin, end = match.end.divIdx; n <= end; n++) {
                      const div = textDivs[n];
                      div.textContent = textContentItemsStr[n];
                      div.className = "";
                    }
                    clearedUntilDivIdx = match.end.divIdx + 1;
                  }
                  if (!(findController == null ? void 0 : findController.highlightMatches) || reset) {
                    return;
                  }
                  const pageMatches = findController.pageMatches[pageIdx] || null;
                  const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
                  this.matches = this._convertMatches(pageMatches, pageMatchesLength);
                  this._renderMatches(this.matches);
                }
              }
              exports2.TextHighlighter = TextHighlighter;
            },
            /* 19 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _enablePermissions, _rotation, _scale, _textContentSource, _finishRendering, finishRendering_fn, _bindMouse, bindMouse_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _ui_utils = __w_pdfjs_require__2(2);
              class TextLayerBuilder {
                constructor({
                  highlighter = null,
                  accessibilityManager = null,
                  isOffscreenCanvasSupported = true,
                  enablePermissions = false
                }) {
                  __privateAdd(this, _finishRendering);
                  __privateAdd(this, _bindMouse);
                  __privateAdd(this, _enablePermissions, false);
                  __privateAdd(this, _rotation, 0);
                  __privateAdd(this, _scale, 0);
                  __privateAdd(this, _textContentSource, null);
                  this.textContentItemsStr = [];
                  this.renderingDone = false;
                  this.textDivs = [];
                  this.textDivProperties = /* @__PURE__ */ new WeakMap();
                  this.textLayerRenderTask = null;
                  this.highlighter = highlighter;
                  this.accessibilityManager = accessibilityManager;
                  this.isOffscreenCanvasSupported = isOffscreenCanvasSupported;
                  __privateSet(this, _enablePermissions, enablePermissions === true);
                  this.div = document.createElement("div");
                  this.div.className = "textLayer";
                  this.hide();
                }
                get numTextDivs() {
                  return this.textDivs.length;
                }
                async render(viewport) {
                  var _a, _b, _c;
                  if (!__privateGet(this, _textContentSource)) {
                    throw new Error('No "textContentSource" parameter specified.');
                  }
                  const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
                  const {
                    rotation
                  } = viewport;
                  if (this.renderingDone) {
                    const mustRotate = rotation !== __privateGet(this, _rotation);
                    const mustRescale = scale !== __privateGet(this, _scale);
                    if (mustRotate || mustRescale) {
                      this.hide();
                      (0, _pdfjsLib.updateTextLayer)({
                        container: this.div,
                        viewport,
                        textDivs: this.textDivs,
                        textDivProperties: this.textDivProperties,
                        isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                        mustRescale,
                        mustRotate
                      });
                      __privateSet(this, _scale, scale);
                      __privateSet(this, _rotation, rotation);
                    }
                    this.show();
                    return;
                  }
                  this.cancel();
                  (_a = this.highlighter) == null ? void 0 : _a.setTextMapping(this.textDivs, this.textContentItemsStr);
                  (_b = this.accessibilityManager) == null ? void 0 : _b.setTextMapping(this.textDivs);
                  this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
                    textContentSource: __privateGet(this, _textContentSource),
                    container: this.div,
                    viewport,
                    textDivs: this.textDivs,
                    textDivProperties: this.textDivProperties,
                    textContentItemsStr: this.textContentItemsStr,
                    isOffscreenCanvasSupported: this.isOffscreenCanvasSupported
                  });
                  await this.textLayerRenderTask.promise;
                  __privateMethod(this, _finishRendering, finishRendering_fn).call(this);
                  __privateSet(this, _scale, scale);
                  __privateSet(this, _rotation, rotation);
                  this.show();
                  (_c = this.accessibilityManager) == null ? void 0 : _c.enable();
                }
                hide() {
                  var _a;
                  if (!this.div.hidden) {
                    (_a = this.highlighter) == null ? void 0 : _a.disable();
                    this.div.hidden = true;
                  }
                }
                show() {
                  var _a;
                  if (this.div.hidden && this.renderingDone) {
                    this.div.hidden = false;
                    (_a = this.highlighter) == null ? void 0 : _a.enable();
                  }
                }
                cancel() {
                  var _a, _b;
                  if (this.textLayerRenderTask) {
                    this.textLayerRenderTask.cancel();
                    this.textLayerRenderTask = null;
                  }
                  (_a = this.highlighter) == null ? void 0 : _a.disable();
                  (_b = this.accessibilityManager) == null ? void 0 : _b.disable();
                  this.textContentItemsStr.length = 0;
                  this.textDivs.length = 0;
                  this.textDivProperties = /* @__PURE__ */ new WeakMap();
                }
                setTextContentSource(source) {
                  this.cancel();
                  __privateSet(this, _textContentSource, source);
                }
              }
              _enablePermissions = new WeakMap();
              _rotation = new WeakMap();
              _scale = new WeakMap();
              _textContentSource = new WeakMap();
              _finishRendering = new WeakSet();
              finishRendering_fn = function() {
                this.renderingDone = true;
                const endOfContent = document.createElement("div");
                endOfContent.className = "endOfContent";
                this.div.append(endOfContent);
                __privateMethod(this, _bindMouse, bindMouse_fn).call(this);
              };
              _bindMouse = new WeakSet();
              bindMouse_fn = function() {
                const {
                  div
                } = this;
                div.addEventListener("mousedown", (evt) => {
                  const end = div.querySelector(".endOfContent");
                  if (!end) {
                    return;
                  }
                  let adjustTop = evt.target !== div;
                  adjustTop && (adjustTop = getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none");
                  if (adjustTop) {
                    const divBounds = div.getBoundingClientRect();
                    const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
                    end.style.top = (r * 100).toFixed(2) + "%";
                  }
                  end.classList.add("active");
                });
                div.addEventListener("mouseup", () => {
                  const end = div.querySelector(".endOfContent");
                  if (!end) {
                    return;
                  }
                  end.style.top = "";
                  end.classList.remove("active");
                });
                div.addEventListener("copy", (event) => {
                  if (!__privateGet(this, _enablePermissions)) {
                    const selection = document.getSelection();
                    event.clipboardData.setData("text/plain", (0, _ui_utils.removeNullCharacters)((0, _pdfjsLib.normalizeUnicode)(selection.toString())));
                  }
                  event.preventDefault();
                  event.stopPropagation();
                });
              };
              exports2.TextLayerBuilder = TextLayerBuilder;
            },
            /* 20 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayerBuilder = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              class XfaLayerBuilder {
                constructor({
                  pageDiv,
                  pdfPage,
                  annotationStorage = null,
                  linkService,
                  xfaHtml = null
                }) {
                  this.pageDiv = pageDiv;
                  this.pdfPage = pdfPage;
                  this.annotationStorage = annotationStorage;
                  this.linkService = linkService;
                  this.xfaHtml = xfaHtml;
                  this.div = null;
                  this._cancelled = false;
                }
                async render(viewport, intent = "display") {
                  if (intent === "print") {
                    const parameters2 = {
                      viewport: viewport.clone({
                        dontFlip: true
                      }),
                      div: this.div,
                      xfaHtml: this.xfaHtml,
                      annotationStorage: this.annotationStorage,
                      linkService: this.linkService,
                      intent
                    };
                    const div = document.createElement("div");
                    this.pageDiv.append(div);
                    parameters2.div = div;
                    return _pdfjsLib.XfaLayer.render(parameters2);
                  }
                  const xfaHtml = await this.pdfPage.getXfa();
                  if (this._cancelled || !xfaHtml) {
                    return {
                      textDivs: []
                    };
                  }
                  const parameters = {
                    viewport: viewport.clone({
                      dontFlip: true
                    }),
                    div: this.div,
                    xfaHtml,
                    annotationStorage: this.annotationStorage,
                    linkService: this.linkService,
                    intent
                  };
                  if (this.div) {
                    return _pdfjsLib.XfaLayer.update(parameters);
                  }
                  this.div = document.createElement("div");
                  this.pageDiv.append(this.div);
                  parameters.div = this.div;
                  return _pdfjsLib.XfaLayer.render(parameters);
                }
                cancel() {
                  this._cancelled = true;
                }
                hide() {
                  if (!this.div) {
                    return;
                  }
                  this.div.hidden = true;
                }
              }
              exports2.XfaLayerBuilder = XfaLayerBuilder;
            },
            /* 21 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFScriptingManager = void 0;
              var _generic_scripting = __w_pdfjs_require__2(22);
              var _pdf_scripting_manager = __w_pdfjs_require__2(23);
              class PDFScriptingManagerComponents extends _pdf_scripting_manager.PDFScriptingManager {
                constructor(options) {
                  if (!options.externalServices) {
                    window.addEventListener("updatefromsandbox", (event) => {
                      options.eventBus.dispatch("updatefromsandbox", {
                        source: window,
                        detail: event.detail
                      });
                    });
                  }
                  options.externalServices || (options.externalServices = {
                    createScripting: ({
                      sandboxBundleSrc
                    }) => {
                      return new _generic_scripting.GenericScripting(sandboxBundleSrc);
                    }
                  });
                  options.docProperties || (options.docProperties = (pdfDocument) => {
                    return (0, _generic_scripting.docProperties)(pdfDocument);
                  });
                  super(options);
                }
              }
              exports2.PDFScriptingManager = PDFScriptingManagerComponents;
            },
            /* 22 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GenericScripting = void 0;
              exports2.docProperties = docProperties;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              async function docProperties(pdfDocument) {
                const url = "", baseUrl = url.split("#")[0];
                let {
                  info,
                  metadata,
                  contentDispositionFilename,
                  contentLength
                } = await pdfDocument.getMetadata();
                if (!contentLength) {
                  const {
                    length
                  } = await pdfDocument.getDownloadInfo();
                  contentLength = length;
                }
                return {
                  ...info,
                  baseURL: baseUrl,
                  filesize: contentLength,
                  filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url),
                  metadata: metadata == null ? void 0 : metadata.getRaw(),
                  authors: metadata == null ? void 0 : metadata.get("dc:creator"),
                  numPages: pdfDocument.numPages,
                  URL: url
                };
              }
              class GenericScripting {
                constructor(sandboxBundleSrc) {
                  this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(() => {
                    return window.pdfjsSandbox.QuickJSSandbox();
                  });
                }
                async createSandbox(data) {
                  const sandbox = await this._ready;
                  sandbox.create(data);
                }
                async dispatchEventInSandbox(event) {
                  const sandbox = await this._ready;
                  setTimeout(() => sandbox.dispatchEvent(event), 0);
                }
                async destroySandbox() {
                  const sandbox = await this._ready;
                  sandbox.nukeSandbox();
                }
              }
              exports2.GenericScripting = GenericScripting;
            },
            /* 23 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _closeCapability, _destroyCapability, _docProperties, _eventBus, _externalServices, _pdfDocument, _pdfViewer, _ready, _sandboxBundleSrc, _scripting, _willPrintCapability, _updateFromSandbox, updateFromSandbox_fn, _dispatchPageOpen, dispatchPageOpen_fn, _dispatchPageClose, dispatchPageClose_fn, _initScripting, initScripting_fn, _destroyScripting, destroyScripting_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFScriptingManager = void 0;
              var _ui_utils = __w_pdfjs_require__2(2);
              var _pdfjsLib = __w_pdfjs_require__2(4);
              class PDFScriptingManager {
                constructor({
                  eventBus,
                  sandboxBundleSrc = null,
                  externalServices = null,
                  docProperties = null
                }) {
                  __privateAdd(this, _updateFromSandbox);
                  __privateAdd(this, _dispatchPageOpen);
                  __privateAdd(this, _dispatchPageClose);
                  __privateAdd(this, _initScripting);
                  __privateAdd(this, _destroyScripting);
                  __privateAdd(this, _closeCapability, null);
                  __privateAdd(this, _destroyCapability, null);
                  __privateAdd(this, _docProperties, null);
                  __privateAdd(this, _eventBus, null);
                  __privateAdd(this, _externalServices, null);
                  __privateAdd(this, _pdfDocument, null);
                  __privateAdd(this, _pdfViewer, null);
                  __privateAdd(this, _ready, false);
                  __privateAdd(this, _sandboxBundleSrc, null);
                  __privateAdd(this, _scripting, null);
                  __privateAdd(this, _willPrintCapability, null);
                  __privateSet(this, _eventBus, eventBus);
                  __privateSet(this, _sandboxBundleSrc, sandboxBundleSrc);
                  __privateSet(this, _externalServices, externalServices);
                  __privateSet(this, _docProperties, docProperties);
                }
                setViewer(pdfViewer) {
                  __privateSet(this, _pdfViewer, pdfViewer);
                }
                async setDocument(pdfDocument) {
                  var _a;
                  if (__privateGet(this, _pdfDocument)) {
                    await __privateMethod(this, _destroyScripting, destroyScripting_fn).call(this);
                  }
                  __privateSet(this, _pdfDocument, pdfDocument);
                  if (!pdfDocument) {
                    return;
                  }
                  const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);
                  if (!objects && !docActions) {
                    await __privateMethod(this, _destroyScripting, destroyScripting_fn).call(this);
                    return;
                  }
                  if (pdfDocument !== __privateGet(this, _pdfDocument)) {
                    return;
                  }
                  try {
                    __privateSet(this, _scripting, __privateMethod(this, _initScripting, initScripting_fn).call(this));
                  } catch (error) {
                    console.error(`setDocument: "${error.message}".`);
                    await __privateMethod(this, _destroyScripting, destroyScripting_fn).call(this);
                    return;
                  }
                  this._internalEvents.set("updatefromsandbox", (event) => {
                    if ((event == null ? void 0 : event.source) === window) {
                      __privateMethod(this, _updateFromSandbox, updateFromSandbox_fn).call(this, event.detail);
                    }
                  });
                  this._internalEvents.set("dispatcheventinsandbox", (event) => {
                    var _a2;
                    (_a2 = __privateGet(this, _scripting)) == null ? void 0 : _a2.dispatchEventInSandbox(event.detail);
                  });
                  this._internalEvents.set("pagechanging", ({
                    pageNumber,
                    previous
                  }) => {
                    if (pageNumber === previous) {
                      return;
                    }
                    __privateMethod(this, _dispatchPageClose, dispatchPageClose_fn).call(this, previous);
                    __privateMethod(this, _dispatchPageOpen, dispatchPageOpen_fn).call(this, pageNumber);
                  });
                  this._internalEvents.set("pagerendered", ({
                    pageNumber
                  }) => {
                    if (!this._pageOpenPending.has(pageNumber)) {
                      return;
                    }
                    if (pageNumber !== __privateGet(this, _pdfViewer).currentPageNumber) {
                      return;
                    }
                    __privateMethod(this, _dispatchPageOpen, dispatchPageOpen_fn).call(this, pageNumber);
                  });
                  this._internalEvents.set("pagesdestroy", async () => {
                    var _a2, _b;
                    await __privateMethod(this, _dispatchPageClose, dispatchPageClose_fn).call(this, __privateGet(this, _pdfViewer).currentPageNumber);
                    await ((_a2 = __privateGet(this, _scripting)) == null ? void 0 : _a2.dispatchEventInSandbox({
                      id: "doc",
                      name: "WillClose"
                    }));
                    (_b = __privateGet(this, _closeCapability)) == null ? void 0 : _b.resolve();
                  });
                  for (const [name, listener] of this._internalEvents) {
                    __privateGet(this, _eventBus)._on(name, listener);
                  }
                  try {
                    const docProperties = await __privateGet(this, _docProperties).call(this, pdfDocument);
                    if (pdfDocument !== __privateGet(this, _pdfDocument)) {
                      return;
                    }
                    await __privateGet(this, _scripting).createSandbox({
                      objects,
                      calculationOrder,
                      appInfo: {
                        platform: navigator.platform,
                        language: navigator.language
                      },
                      docInfo: {
                        ...docProperties,
                        actions: docActions
                      }
                    });
                    __privateGet(this, _eventBus).dispatch("sandboxcreated", {
                      source: this
                    });
                  } catch (error) {
                    console.error(`setDocument: "${error.message}".`);
                    await __privateMethod(this, _destroyScripting, destroyScripting_fn).call(this);
                    return;
                  }
                  await ((_a = __privateGet(this, _scripting)) == null ? void 0 : _a.dispatchEventInSandbox({
                    id: "doc",
                    name: "Open"
                  }));
                  await __privateMethod(this, _dispatchPageOpen, dispatchPageOpen_fn).call(this, __privateGet(this, _pdfViewer).currentPageNumber, true);
                  Promise.resolve().then(() => {
                    if (pdfDocument === __privateGet(this, _pdfDocument)) {
                      __privateSet(this, _ready, true);
                    }
                  });
                }
                async dispatchWillSave() {
                  var _a;
                  return (_a = __privateGet(this, _scripting)) == null ? void 0 : _a.dispatchEventInSandbox({
                    id: "doc",
                    name: "WillSave"
                  });
                }
                async dispatchDidSave() {
                  var _a;
                  return (_a = __privateGet(this, _scripting)) == null ? void 0 : _a.dispatchEventInSandbox({
                    id: "doc",
                    name: "DidSave"
                  });
                }
                async dispatchWillPrint() {
                  var _a;
                  if (!__privateGet(this, _scripting)) {
                    return;
                  }
                  await ((_a = __privateGet(this, _willPrintCapability)) == null ? void 0 : _a.promise);
                  __privateSet(this, _willPrintCapability, new _pdfjsLib.PromiseCapability());
                  try {
                    await __privateGet(this, _scripting).dispatchEventInSandbox({
                      id: "doc",
                      name: "WillPrint"
                    });
                  } catch (ex) {
                    __privateGet(this, _willPrintCapability).resolve();
                    __privateSet(this, _willPrintCapability, null);
                    throw ex;
                  }
                  await __privateGet(this, _willPrintCapability).promise;
                }
                async dispatchDidPrint() {
                  var _a;
                  return (_a = __privateGet(this, _scripting)) == null ? void 0 : _a.dispatchEventInSandbox({
                    id: "doc",
                    name: "DidPrint"
                  });
                }
                get destroyPromise() {
                  var _a;
                  return ((_a = __privateGet(this, _destroyCapability)) == null ? void 0 : _a.promise) || null;
                }
                get ready() {
                  return __privateGet(this, _ready);
                }
                get _internalEvents() {
                  return (0, _pdfjsLib.shadow)(this, "_internalEvents", /* @__PURE__ */ new Map());
                }
                get _pageOpenPending() {
                  return (0, _pdfjsLib.shadow)(this, "_pageOpenPending", /* @__PURE__ */ new Set());
                }
                get _visitedPages() {
                  return (0, _pdfjsLib.shadow)(this, "_visitedPages", /* @__PURE__ */ new Map());
                }
              }
              _closeCapability = new WeakMap();
              _destroyCapability = new WeakMap();
              _docProperties = new WeakMap();
              _eventBus = new WeakMap();
              _externalServices = new WeakMap();
              _pdfDocument = new WeakMap();
              _pdfViewer = new WeakMap();
              _ready = new WeakMap();
              _sandboxBundleSrc = new WeakMap();
              _scripting = new WeakMap();
              _willPrintCapability = new WeakMap();
              _updateFromSandbox = new WeakSet();
              updateFromSandbox_fn = async function(detail) {
                var _a, _b;
                const pdfViewer = __privateGet(this, _pdfViewer);
                const isInPresentationMode = pdfViewer.isInPresentationMode || pdfViewer.isChangingPresentationMode;
                const {
                  id,
                  siblings,
                  command,
                  value
                } = detail;
                if (!id) {
                  switch (command) {
                    case "clear":
                      console.clear();
                      break;
                    case "error":
                      console.error(value);
                      break;
                    case "layout":
                      if (!isInPresentationMode) {
                        const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(value);
                        pdfViewer.spreadMode = modes.spreadMode;
                      }
                      break;
                    case "page-num":
                      pdfViewer.currentPageNumber = value + 1;
                      break;
                    case "print":
                      await pdfViewer.pagesPromise;
                      __privateGet(this, _eventBus).dispatch("print", {
                        source: this
                      });
                      break;
                    case "println":
                      console.log(value);
                      break;
                    case "zoom":
                      if (!isInPresentationMode) {
                        pdfViewer.currentScaleValue = value;
                      }
                      break;
                    case "SaveAs":
                      __privateGet(this, _eventBus).dispatch("download", {
                        source: this
                      });
                      break;
                    case "FirstPage":
                      pdfViewer.currentPageNumber = 1;
                      break;
                    case "LastPage":
                      pdfViewer.currentPageNumber = pdfViewer.pagesCount;
                      break;
                    case "NextPage":
                      pdfViewer.nextPage();
                      break;
                    case "PrevPage":
                      pdfViewer.previousPage();
                      break;
                    case "ZoomViewIn":
                      if (!isInPresentationMode) {
                        pdfViewer.increaseScale();
                      }
                      break;
                    case "ZoomViewOut":
                      if (!isInPresentationMode) {
                        pdfViewer.decreaseScale();
                      }
                      break;
                    case "WillPrintFinished":
                      (_a = __privateGet(this, _willPrintCapability)) == null ? void 0 : _a.resolve();
                      __privateSet(this, _willPrintCapability, null);
                      break;
                  }
                  return;
                }
                if (isInPresentationMode && detail.focus) {
                  return;
                }
                delete detail.id;
                delete detail.siblings;
                const ids = siblings ? [id, ...siblings] : [id];
                for (const elementId of ids) {
                  const element = document.querySelector(`[data-element-id="${elementId}"]`);
                  if (element) {
                    element.dispatchEvent(new CustomEvent("updatefromsandbox", {
                      detail
                    }));
                  } else {
                    (_b = __privateGet(this, _pdfDocument)) == null ? void 0 : _b.annotationStorage.setValue(elementId, detail);
                  }
                }
              };
              _dispatchPageOpen = new WeakSet();
              dispatchPageOpen_fn = async function(pageNumber, initialize = false) {
                const pdfDocument = __privateGet(this, _pdfDocument), visitedPages = this._visitedPages;
                if (initialize) {
                  __privateSet(this, _closeCapability, new _pdfjsLib.PromiseCapability());
                }
                if (!__privateGet(this, _closeCapability)) {
                  return;
                }
                const pageView = __privateGet(this, _pdfViewer).getPageView(pageNumber - 1);
                if ((pageView == null ? void 0 : pageView.renderingState) !== _ui_utils.RenderingStates.FINISHED) {
                  this._pageOpenPending.add(pageNumber);
                  return;
                }
                this._pageOpenPending.delete(pageNumber);
                const actionsPromise = (async () => {
                  var _a, _b;
                  const actions = await (!visitedPages.has(pageNumber) ? (_a = pageView.pdfPage) == null ? void 0 : _a.getJSActions() : null);
                  if (pdfDocument !== __privateGet(this, _pdfDocument)) {
                    return;
                  }
                  await ((_b = __privateGet(this, _scripting)) == null ? void 0 : _b.dispatchEventInSandbox({
                    id: "page",
                    name: "PageOpen",
                    pageNumber,
                    actions
                  }));
                })();
                visitedPages.set(pageNumber, actionsPromise);
              };
              _dispatchPageClose = new WeakSet();
              dispatchPageClose_fn = async function(pageNumber) {
                var _a;
                const pdfDocument = __privateGet(this, _pdfDocument), visitedPages = this._visitedPages;
                if (!__privateGet(this, _closeCapability)) {
                  return;
                }
                if (this._pageOpenPending.has(pageNumber)) {
                  return;
                }
                const actionsPromise = visitedPages.get(pageNumber);
                if (!actionsPromise) {
                  return;
                }
                visitedPages.set(pageNumber, null);
                await actionsPromise;
                if (pdfDocument !== __privateGet(this, _pdfDocument)) {
                  return;
                }
                await ((_a = __privateGet(this, _scripting)) == null ? void 0 : _a.dispatchEventInSandbox({
                  id: "page",
                  name: "PageClose",
                  pageNumber
                }));
              };
              _initScripting = new WeakSet();
              initScripting_fn = function() {
                __privateSet(this, _destroyCapability, new _pdfjsLib.PromiseCapability());
                if (__privateGet(this, _scripting)) {
                  throw new Error("#initScripting: Scripting already exists.");
                }
                return __privateGet(this, _externalServices).createScripting({
                  sandboxBundleSrc: __privateGet(this, _sandboxBundleSrc)
                });
              };
              _destroyScripting = new WeakSet();
              destroyScripting_fn = async function() {
                var _a, _b, _c;
                if (!__privateGet(this, _scripting)) {
                  __privateSet(this, _pdfDocument, null);
                  (_a = __privateGet(this, _destroyCapability)) == null ? void 0 : _a.resolve();
                  return;
                }
                if (__privateGet(this, _closeCapability)) {
                  await Promise.race([__privateGet(this, _closeCapability).promise, new Promise((resolve) => {
                    setTimeout(resolve, 1e3);
                  })]).catch(() => {
                  });
                  __privateSet(this, _closeCapability, null);
                }
                __privateSet(this, _pdfDocument, null);
                try {
                  await __privateGet(this, _scripting).destroySandbox();
                } catch {
                }
                (_b = __privateGet(this, _willPrintCapability)) == null ? void 0 : _b.reject(new Error("Scripting destroyed."));
                __privateSet(this, _willPrintCapability, null);
                for (const [name, listener] of this._internalEvents) {
                  __privateGet(this, _eventBus)._off(name, listener);
                }
                this._internalEvents.clear();
                this._pageOpenPending.clear();
                this._visitedPages.clear();
                __privateSet(this, _scripting, null);
                __privateSet(this, _ready, false);
                (_c = __privateGet(this, _destroyCapability)) == null ? void 0 : _c.resolve();
              };
              exports2.PDFScriptingManager = PDFScriptingManager;
            },
            /* 24 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFSinglePageViewer = void 0;
              var _ui_utils = __w_pdfjs_require__2(2);
              var _pdf_viewer = __w_pdfjs_require__2(25);
              class PDFSinglePageViewer extends _pdf_viewer.PDFViewer {
                _resetView() {
                  super._resetView();
                  this._scrollMode = _ui_utils.ScrollMode.PAGE;
                  this._spreadMode = _ui_utils.SpreadMode.NONE;
                }
                set scrollMode(mode) {
                }
                _updateScrollMode() {
                }
                set spreadMode(mode) {
                }
                _updateSpreadMode() {
                }
              }
              exports2.PDFSinglePageViewer = PDFSinglePageViewer;
            },
            /* 25 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              var _buf, _size, _destroyFirstView, destroyFirstView_fn, _buffer, _annotationEditorMode, _annotationEditorUIManager, _annotationMode, _containerTopLeft, _copyCallbackBound, _enablePermissions, _getAllTextInProgress, _hiddenCopyElement, _interruptCopyCondition, _previousContainerHeight, _resizeObserver, _scrollModePageState, _onVisibilityChange, _scaleTimeoutId, _textLayerMode, _layerProperties, layerProperties_fn, _initializePermissions, initializePermissions_fn, _onePageRenderedOrForceFetch, onePageRenderedOrForceFetch_fn, _copyCallback, copyCallback_fn, _ensurePageViewVisible, ensurePageViewVisible_fn, _scrollIntoView, scrollIntoView_fn, _isSameScale, isSameScale_fn, _setScaleUpdatePages, setScaleUpdatePages_fn, _pageWidthScaleFactor, pageWidthScaleFactor_get, _setScale, setScale_fn, _resetCurrentPageView, resetCurrentPageView_fn, _ensurePdfPageLoaded, ensurePdfPageLoaded_fn, _getScrollAhead, getScrollAhead_fn, _updateContainerHeightCss, updateContainerHeightCss_fn, _resizeObserverCallback, resizeObserverCallback_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PagesCountLimit = exports2.PDFViewer = exports2.PDFPageViewBuffer = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _ui_utils = __w_pdfjs_require__2(2);
              var _l10n_utils = __w_pdfjs_require__2(7);
              var _pdf_page_view = __w_pdfjs_require__2(13);
              var _pdf_rendering_queue = __w_pdfjs_require__2(26);
              var _pdf_link_service = __w_pdfjs_require__2(5);
              const DEFAULT_CACHE_SIZE = 10;
              const PagesCountLimit = {
                FORCE_SCROLL_MODE_PAGE: 15e3,
                FORCE_LAZY_PAGE_INIT: 7500,
                PAUSE_EAGER_PAGE_INIT: 250
              };
              exports2.PagesCountLimit = PagesCountLimit;
              function isValidAnnotationEditorMode(mode) {
                return Object.values(_pdfjsLib.AnnotationEditorType).includes(mode) && mode !== _pdfjsLib.AnnotationEditorType.DISABLE;
              }
              class PDFPageViewBuffer {
                constructor(size) {
                  __privateAdd(this, _destroyFirstView);
                  __privateAdd(this, _buf, /* @__PURE__ */ new Set());
                  __privateAdd(this, _size, 0);
                  __privateSet(this, _size, size);
                }
                push(view) {
                  const buf = __privateGet(this, _buf);
                  if (buf.has(view)) {
                    buf.delete(view);
                  }
                  buf.add(view);
                  if (buf.size > __privateGet(this, _size)) {
                    __privateMethod(this, _destroyFirstView, destroyFirstView_fn).call(this);
                  }
                }
                resize(newSize, idsToKeep = null) {
                  __privateSet(this, _size, newSize);
                  const buf = __privateGet(this, _buf);
                  if (idsToKeep) {
                    const ii = buf.size;
                    let i = 1;
                    for (const view of buf) {
                      if (idsToKeep.has(view.id)) {
                        buf.delete(view);
                        buf.add(view);
                      }
                      if (++i > ii) {
                        break;
                      }
                    }
                  }
                  while (buf.size > __privateGet(this, _size)) {
                    __privateMethod(this, _destroyFirstView, destroyFirstView_fn).call(this);
                  }
                }
                has(view) {
                  return __privateGet(this, _buf).has(view);
                }
                [Symbol.iterator]() {
                  return __privateGet(this, _buf).keys();
                }
              }
              _buf = new WeakMap();
              _size = new WeakMap();
              _destroyFirstView = new WeakSet();
              destroyFirstView_fn = function() {
                const firstView = __privateGet(this, _buf).keys().next().value;
                firstView == null ? void 0 : firstView.destroy();
                __privateGet(this, _buf).delete(firstView);
              };
              exports2.PDFPageViewBuffer = PDFPageViewBuffer;
              class PDFViewer {
                constructor(options) {
                  __privateAdd(this, _layerProperties);
                  __privateAdd(this, _initializePermissions);
                  __privateAdd(this, _onePageRenderedOrForceFetch);
                  __privateAdd(this, _copyCallback);
                  __privateAdd(this, _ensurePageViewVisible);
                  __privateAdd(this, _scrollIntoView);
                  __privateAdd(this, _isSameScale);
                  __privateAdd(this, _setScaleUpdatePages);
                  __privateAdd(this, _pageWidthScaleFactor);
                  __privateAdd(this, _setScale);
                  __privateAdd(this, _resetCurrentPageView);
                  __privateAdd(this, _ensurePdfPageLoaded);
                  __privateAdd(this, _getScrollAhead);
                  __privateAdd(this, _updateContainerHeightCss);
                  __privateAdd(this, _resizeObserverCallback);
                  __privateAdd(this, _buffer, null);
                  __privateAdd(this, _annotationEditorMode, _pdfjsLib.AnnotationEditorType.NONE);
                  __privateAdd(this, _annotationEditorUIManager, null);
                  __privateAdd(this, _annotationMode, _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  __privateAdd(this, _containerTopLeft, null);
                  __privateAdd(this, _copyCallbackBound, null);
                  __privateAdd(this, _enablePermissions, false);
                  __privateAdd(this, _getAllTextInProgress, false);
                  __privateAdd(this, _hiddenCopyElement, null);
                  __privateAdd(this, _interruptCopyCondition, false);
                  __privateAdd(this, _previousContainerHeight, 0);
                  __privateAdd(this, _resizeObserver, new ResizeObserver(__privateMethod(this, _resizeObserverCallback, resizeObserverCallback_fn).bind(this)));
                  __privateAdd(this, _scrollModePageState, null);
                  __privateAdd(this, _onVisibilityChange, null);
                  __privateAdd(this, _scaleTimeoutId, null);
                  __privateAdd(this, _textLayerMode, _ui_utils.TextLayerMode.ENABLE);
                  var _a, _b;
                  const viewerVersion = "3.10.111";
                  if (_pdfjsLib.version !== viewerVersion) {
                    throw new Error(`The API version "${_pdfjsLib.version}" does not match the Viewer version "${viewerVersion}".`);
                  }
                  this.container = options.container;
                  this.viewer = options.viewer || options.container.firstElementChild;
                  if (((_a = this.container) == null ? void 0 : _a.tagName) !== "DIV" || ((_b = this.viewer) == null ? void 0 : _b.tagName) !== "DIV") {
                    throw new Error("Invalid `container` and/or `viewer` option.");
                  }
                  if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
                    throw new Error("The `container` must be absolutely positioned.");
                  }
                  __privateGet(this, _resizeObserver).observe(this.container);
                  this.eventBus = options.eventBus;
                  this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
                  this.downloadManager = options.downloadManager || null;
                  this.findController = options.findController || null;
                  if (this.findController) {
                    this.findController.onIsPageVisible = (pageNumber) => this._getVisiblePages().ids.has(pageNumber);
                  }
                  this._scriptingManager = options.scriptingManager || null;
                  __privateSet(this, _textLayerMode, options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE);
                  __privateSet(this, _annotationMode, options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS);
                  __privateSet(this, _annotationEditorMode, options.annotationEditorMode ?? _pdfjsLib.AnnotationEditorType.NONE);
                  this.imageResourcesPath = options.imageResourcesPath || "";
                  this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
                  this.removePageBorders = options.removePageBorders || false;
                  if (options.useOnlyCssZoom) {
                    console.error("useOnlyCssZoom was removed, please use `maxCanvasPixels = 0` instead.");
                    options.maxCanvasPixels = 0;
                  }
                  this.isOffscreenCanvasSupported = options.isOffscreenCanvasSupported ?? true;
                  this.maxCanvasPixels = options.maxCanvasPixels;
                  this.l10n = options.l10n || _l10n_utils.NullL10n;
                  __privateSet(this, _enablePermissions, options.enablePermissions || false);
                  this.pageColors = options.pageColors || null;
                  this.defaultRenderingQueue = !options.renderingQueue;
                  if (this.defaultRenderingQueue) {
                    this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
                    this.renderingQueue.setViewer(this);
                  } else {
                    this.renderingQueue = options.renderingQueue;
                  }
                  this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
                  this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
                  this._onBeforeDraw = this._onAfterDraw = null;
                  this._resetView();
                  if (this.removePageBorders) {
                    this.viewer.classList.add("removePageBorders");
                  }
                  __privateMethod(this, _updateContainerHeightCss, updateContainerHeightCss_fn).call(this);
                  this.eventBus._on("thumbnailrendered", ({
                    pageNumber,
                    pdfPage
                  }) => {
                    const pageView = this._pages[pageNumber - 1];
                    if (!__privateGet(this, _buffer).has(pageView)) {
                      pdfPage == null ? void 0 : pdfPage.cleanup();
                    }
                  });
                }
                get pagesCount() {
                  return this._pages.length;
                }
                getPageView(index) {
                  return this._pages[index];
                }
                getCachedPageViews() {
                  return new Set(__privateGet(this, _buffer));
                }
                get pageViewsReady() {
                  return this._pagesCapability.settled && this._pages.every((pageView) => pageView == null ? void 0 : pageView.pdfPage);
                }
                get renderForms() {
                  return __privateGet(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS;
                }
                get enableScripting() {
                  return !!this._scriptingManager;
                }
                get currentPageNumber() {
                  return this._currentPageNumber;
                }
                set currentPageNumber(val) {
                  if (!Number.isInteger(val)) {
                    throw new Error("Invalid page number.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!this._setCurrentPageNumber(val, true)) {
                    console.error(`currentPageNumber: "${val}" is not a valid page.`);
                  }
                }
                _setCurrentPageNumber(val, resetCurrentPageView = false) {
                  var _a;
                  if (this._currentPageNumber === val) {
                    if (resetCurrentPageView) {
                      __privateMethod(this, _resetCurrentPageView, resetCurrentPageView_fn).call(this);
                    }
                    return true;
                  }
                  if (!(0 < val && val <= this.pagesCount)) {
                    return false;
                  }
                  const previous = this._currentPageNumber;
                  this._currentPageNumber = val;
                  this.eventBus.dispatch("pagechanging", {
                    source: this,
                    pageNumber: val,
                    pageLabel: ((_a = this._pageLabels) == null ? void 0 : _a[val - 1]) ?? null,
                    previous
                  });
                  if (resetCurrentPageView) {
                    __privateMethod(this, _resetCurrentPageView, resetCurrentPageView_fn).call(this);
                  }
                  return true;
                }
                get currentPageLabel() {
                  var _a;
                  return ((_a = this._pageLabels) == null ? void 0 : _a[this._currentPageNumber - 1]) ?? null;
                }
                set currentPageLabel(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let page = val | 0;
                  if (this._pageLabels) {
                    const i = this._pageLabels.indexOf(val);
                    if (i >= 0) {
                      page = i + 1;
                    }
                  }
                  if (!this._setCurrentPageNumber(page, true)) {
                    console.error(`currentPageLabel: "${val}" is not a valid page.`);
                  }
                }
                get currentScale() {
                  return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
                }
                set currentScale(val) {
                  if (isNaN(val)) {
                    throw new Error("Invalid numeric scale.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  __privateMethod(this, _setScale, setScale_fn).call(this, val, {
                    noScroll: false
                  });
                }
                get currentScaleValue() {
                  return this._currentScaleValue;
                }
                set currentScaleValue(val) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  __privateMethod(this, _setScale, setScale_fn).call(this, val, {
                    noScroll: false
                  });
                }
                get pagesRotation() {
                  return this._pagesRotation;
                }
                set pagesRotation(rotation) {
                  if (!(0, _ui_utils.isValidRotation)(rotation)) {
                    throw new Error("Invalid pages rotation angle.");
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  if (this._pagesRotation === rotation) {
                    return;
                  }
                  this._pagesRotation = rotation;
                  const pageNumber = this._currentPageNumber;
                  this.refresh(true, {
                    rotation
                  });
                  if (this._currentScaleValue) {
                    __privateMethod(this, _setScale, setScale_fn).call(this, this._currentScaleValue, {
                      noScroll: true
                    });
                  }
                  this.eventBus.dispatch("rotationchanging", {
                    source: this,
                    pagesRotation: rotation,
                    pageNumber
                  });
                  if (this.defaultRenderingQueue) {
                    this.update();
                  }
                }
                get firstPagePromise() {
                  return this.pdfDocument ? this._firstPageCapability.promise : null;
                }
                get onePageRendered() {
                  return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
                }
                get pagesPromise() {
                  return this.pdfDocument ? this._pagesCapability.promise : null;
                }
                async getAllText() {
                  const texts = [];
                  const buffer = [];
                  for (let pageNum = 1, pagesCount = this.pdfDocument.numPages; pageNum <= pagesCount; ++pageNum) {
                    if (__privateGet(this, _interruptCopyCondition)) {
                      return null;
                    }
                    buffer.length = 0;
                    const page = await this.pdfDocument.getPage(pageNum);
                    const {
                      items
                    } = await page.getTextContent();
                    for (const item of items) {
                      if (item.str) {
                        buffer.push(item.str);
                      }
                      if (item.hasEOL) {
                        buffer.push("\n");
                      }
                    }
                    texts.push((0, _ui_utils.removeNullCharacters)(buffer.join("")));
                  }
                  return texts.join("\n");
                }
                setDocument(pdfDocument) {
                  var _a, _b;
                  if (this.pdfDocument) {
                    this.eventBus.dispatch("pagesdestroy", {
                      source: this
                    });
                    this._cancelRendering();
                    this._resetView();
                    (_a = this.findController) == null ? void 0 : _a.setDocument(null);
                    (_b = this._scriptingManager) == null ? void 0 : _b.setDocument(null);
                    if (__privateGet(this, _annotationEditorUIManager)) {
                      __privateGet(this, _annotationEditorUIManager).destroy();
                      __privateSet(this, _annotationEditorUIManager, null);
                    }
                  }
                  this.pdfDocument = pdfDocument;
                  if (!pdfDocument) {
                    return;
                  }
                  const pagesCount = pdfDocument.numPages;
                  const firstPagePromise = pdfDocument.getPage(1);
                  const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();
                  const permissionsPromise = __privateGet(this, _enablePermissions) ? pdfDocument.getPermissions() : Promise.resolve();
                  if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
                    console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
                    const mode = this._scrollMode = _ui_utils.ScrollMode.PAGE;
                    this.eventBus.dispatch("scrollmodechanged", {
                      source: this,
                      mode
                    });
                  }
                  this._pagesCapability.promise.then(() => {
                    this.eventBus.dispatch("pagesloaded", {
                      source: this,
                      pagesCount
                    });
                  }, () => {
                  });
                  this._onBeforeDraw = (evt) => {
                    const pageView = this._pages[evt.pageNumber - 1];
                    if (!pageView) {
                      return;
                    }
                    __privateGet(this, _buffer).push(pageView);
                  };
                  this.eventBus._on("pagerender", this._onBeforeDraw);
                  this._onAfterDraw = (evt) => {
                    if (evt.cssTransform || this._onePageRenderedCapability.settled) {
                      return;
                    }
                    this._onePageRenderedCapability.resolve({
                      timestamp: evt.timestamp
                    });
                    this.eventBus._off("pagerendered", this._onAfterDraw);
                    this._onAfterDraw = null;
                    if (__privateGet(this, _onVisibilityChange)) {
                      document.removeEventListener("visibilitychange", __privateGet(this, _onVisibilityChange));
                      __privateSet(this, _onVisibilityChange, null);
                    }
                  };
                  this.eventBus._on("pagerendered", this._onAfterDraw);
                  Promise.all([firstPagePromise, permissionsPromise]).then(([firstPdfPage, permissions]) => {
                    var _a2, _b2;
                    if (pdfDocument !== this.pdfDocument) {
                      return;
                    }
                    this._firstPageCapability.resolve(firstPdfPage);
                    this._optionalContentConfigPromise = optionalContentConfigPromise;
                    const {
                      annotationEditorMode,
                      annotationMode,
                      textLayerMode
                    } = __privateMethod(this, _initializePermissions, initializePermissions_fn).call(this, permissions);
                    if (textLayerMode !== _ui_utils.TextLayerMode.DISABLE) {
                      const element = __privateSet(this, _hiddenCopyElement, document.createElement("div"));
                      element.id = "hiddenCopyElement";
                      this.viewer.before(element);
                    }
                    if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) {
                      const mode = annotationEditorMode;
                      if (pdfDocument.isPureXfa) {
                        console.warn("Warning: XFA-editing is not implemented.");
                      } else if (isValidAnnotationEditorMode(mode)) {
                        __privateSet(this, _annotationEditorUIManager, new _pdfjsLib.AnnotationEditorUIManager(this.container, this.viewer, this.eventBus, pdfDocument, this.pageColors));
                        if (mode !== _pdfjsLib.AnnotationEditorType.NONE) {
                          __privateGet(this, _annotationEditorUIManager).updateMode(mode);
                        }
                      } else {
                        console.error(`Invalid AnnotationEditor mode: ${mode}`);
                      }
                    }
                    const layerProperties = __privateMethod(this, _layerProperties, layerProperties_fn).bind(this);
                    const viewerElement = this._scrollMode === _ui_utils.ScrollMode.PAGE ? null : this.viewer;
                    const scale = this.currentScale;
                    const viewport = firstPdfPage.getViewport({
                      scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                    });
                    this.viewer.style.setProperty("--scale-factor", viewport.scale);
                    if (((_a2 = this.pageColors) == null ? void 0 : _a2.foreground) === "CanvasText" || ((_b2 = this.pageColors) == null ? void 0 : _b2.background) === "Canvas") {
                      this.viewer.style.setProperty("--hcm-highligh-filter", pdfDocument.filterFactory.addHighlightHCMFilter("CanvasText", "Canvas", "HighlightText", "Highlight"));
                    }
                    for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                      const pageView = new _pdf_page_view.PDFPageView({
                        container: viewerElement,
                        eventBus: this.eventBus,
                        id: pageNum,
                        scale,
                        defaultViewport: viewport.clone(),
                        optionalContentConfigPromise,
                        renderingQueue: this.renderingQueue,
                        textLayerMode,
                        annotationMode,
                        imageResourcesPath: this.imageResourcesPath,
                        isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                        maxCanvasPixels: this.maxCanvasPixels,
                        pageColors: this.pageColors,
                        l10n: this.l10n,
                        layerProperties
                      });
                      this._pages.push(pageView);
                    }
                    const firstPageView = this._pages[0];
                    if (firstPageView) {
                      firstPageView.setPdfPage(firstPdfPage);
                      this.linkService.cachePageRef(1, firstPdfPage.ref);
                    }
                    if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                      __privateMethod(this, _ensurePageViewVisible, ensurePageViewVisible_fn).call(this);
                    } else if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
                      this._updateSpreadMode();
                    }
                    __privateMethod(this, _onePageRenderedOrForceFetch, onePageRenderedOrForceFetch_fn).call(this).then(async () => {
                      var _a3, _b3;
                      (_a3 = this.findController) == null ? void 0 : _a3.setDocument(pdfDocument);
                      (_b3 = this._scriptingManager) == null ? void 0 : _b3.setDocument(pdfDocument);
                      if (__privateGet(this, _hiddenCopyElement)) {
                        __privateSet(this, _copyCallbackBound, __privateMethod(this, _copyCallback, copyCallback_fn).bind(this, textLayerMode));
                        document.addEventListener("copy", __privateGet(this, _copyCallbackBound));
                      }
                      if (__privateGet(this, _annotationEditorUIManager)) {
                        this.eventBus.dispatch("annotationeditormodechanged", {
                          source: this,
                          mode: __privateGet(this, _annotationEditorMode)
                        });
                      }
                      if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {
                        this._pagesCapability.resolve();
                        return;
                      }
                      let getPagesLeft = pagesCount - 1;
                      if (getPagesLeft <= 0) {
                        this._pagesCapability.resolve();
                        return;
                      }
                      for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
                        const promise = pdfDocument.getPage(pageNum).then((pdfPage) => {
                          const pageView = this._pages[pageNum - 1];
                          if (!pageView.pdfPage) {
                            pageView.setPdfPage(pdfPage);
                          }
                          this.linkService.cachePageRef(pageNum, pdfPage.ref);
                          if (--getPagesLeft === 0) {
                            this._pagesCapability.resolve();
                          }
                        }, (reason) => {
                          console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);
                          if (--getPagesLeft === 0) {
                            this._pagesCapability.resolve();
                          }
                        });
                        if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {
                          await promise;
                        }
                      }
                    });
                    this.eventBus.dispatch("pagesinit", {
                      source: this
                    });
                    pdfDocument.getMetadata().then(({
                      info
                    }) => {
                      if (pdfDocument !== this.pdfDocument) {
                        return;
                      }
                      if (info.Language) {
                        this.viewer.lang = info.Language;
                      }
                    });
                    if (this.defaultRenderingQueue) {
                      this.update();
                    }
                  }).catch((reason) => {
                    console.error("Unable to initialize viewer", reason);
                    this._pagesCapability.reject(reason);
                  });
                }
                setPageLabels(labels) {
                  var _a;
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!labels) {
                    this._pageLabels = null;
                  } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                    this._pageLabels = null;
                    console.error(`setPageLabels: Invalid page labels.`);
                  } else {
                    this._pageLabels = labels;
                  }
                  for (let i = 0, ii = this._pages.length; i < ii; i++) {
                    this._pages[i].setPageLabel(((_a = this._pageLabels) == null ? void 0 : _a[i]) ?? null);
                  }
                }
                _resetView() {
                  this._pages = [];
                  this._currentPageNumber = 1;
                  this._currentScale = _ui_utils.UNKNOWN_SCALE;
                  this._currentScaleValue = null;
                  this._pageLabels = null;
                  __privateSet(this, _buffer, new PDFPageViewBuffer(DEFAULT_CACHE_SIZE));
                  this._location = null;
                  this._pagesRotation = 0;
                  this._optionalContentConfigPromise = null;
                  this._firstPageCapability = new _pdfjsLib.PromiseCapability();
                  this._onePageRenderedCapability = new _pdfjsLib.PromiseCapability();
                  this._pagesCapability = new _pdfjsLib.PromiseCapability();
                  this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
                  this._previousScrollMode = _ui_utils.ScrollMode.UNKNOWN;
                  this._spreadMode = _ui_utils.SpreadMode.NONE;
                  __privateSet(this, _scrollModePageState, {
                    previousPageNumber: 1,
                    scrollDown: true,
                    pages: []
                  });
                  if (this._onBeforeDraw) {
                    this.eventBus._off("pagerender", this._onBeforeDraw);
                    this._onBeforeDraw = null;
                  }
                  if (this._onAfterDraw) {
                    this.eventBus._off("pagerendered", this._onAfterDraw);
                    this._onAfterDraw = null;
                  }
                  if (__privateGet(this, _onVisibilityChange)) {
                    document.removeEventListener("visibilitychange", __privateGet(this, _onVisibilityChange));
                    __privateSet(this, _onVisibilityChange, null);
                  }
                  this.viewer.textContent = "";
                  this._updateScrollMode();
                  this.viewer.removeAttribute("lang");
                  if (__privateGet(this, _hiddenCopyElement)) {
                    document.removeEventListener("copy", __privateGet(this, _copyCallbackBound));
                    __privateSet(this, _copyCallbackBound, null);
                    __privateGet(this, _hiddenCopyElement).remove();
                    __privateSet(this, _hiddenCopyElement, null);
                  }
                }
                _scrollUpdate() {
                  if (this.pagesCount === 0) {
                    return;
                  }
                  this.update();
                }
                pageLabelToPageNumber(label) {
                  if (!this._pageLabels) {
                    return null;
                  }
                  const i = this._pageLabels.indexOf(label);
                  if (i < 0) {
                    return null;
                  }
                  return i + 1;
                }
                scrollPageIntoView({
                  pageNumber,
                  destArray = null,
                  allowNegativeOffset = false,
                  ignoreDestinationZoom = false
                }) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
                  if (!pageView) {
                    console.error(`scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`);
                    return;
                  }
                  if (this.isInPresentationMode || !destArray) {
                    this._setCurrentPageNumber(pageNumber, true);
                    return;
                  }
                  let x = 0, y = 0;
                  let width = 0, height = 0, widthScale, heightScale;
                  const changeOrientation = pageView.rotation % 180 !== 0;
                  const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  let scale = 0;
                  switch (destArray[1].name) {
                    case "XYZ":
                      x = destArray[2];
                      y = destArray[3];
                      scale = destArray[4];
                      x = x !== null ? x : 0;
                      y = y !== null ? y : pageHeight;
                      break;
                    case "Fit":
                    case "FitB":
                      scale = "page-fit";
                      break;
                    case "FitH":
                    case "FitBH":
                      y = destArray[2];
                      scale = "page-width";
                      if (y === null && this._location) {
                        x = this._location.left;
                        y = this._location.top;
                      } else if (typeof y !== "number" || y < 0) {
                        y = pageHeight;
                      }
                      break;
                    case "FitV":
                    case "FitBV":
                      x = destArray[2];
                      width = pageWidth;
                      height = pageHeight;
                      scale = "page-height";
                      break;
                    case "FitR":
                      x = destArray[2];
                      y = destArray[3];
                      width = destArray[4] - x;
                      height = destArray[5] - y;
                      let hPadding = _ui_utils.SCROLLBAR_PADDING, vPadding = _ui_utils.VERTICAL_PADDING;
                      if (this.removePageBorders) {
                        hPadding = vPadding = 0;
                      }
                      widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                      heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                      scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
                      break;
                    default:
                      console.error(`scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`);
                      return;
                  }
                  if (!ignoreDestinationZoom) {
                    if (scale && scale !== this._currentScale) {
                      this.currentScaleValue = scale;
                    } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
                      this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                    }
                  }
                  if (scale === "page-fit" && !destArray[4]) {
                    __privateMethod(this, _scrollIntoView, scrollIntoView_fn).call(this, pageView);
                    return;
                  }
                  const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
                  let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
                  let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
                  if (!allowNegativeOffset) {
                    left = Math.max(left, 0);
                    top = Math.max(top, 0);
                  }
                  __privateMethod(this, _scrollIntoView, scrollIntoView_fn).call(this, pageView, {
                    left,
                    top
                  });
                }
                _updateLocation(firstPage) {
                  const currentScale = this._currentScale;
                  const currentScaleValue = this._currentScaleValue;
                  const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 1e4) / 100 : currentScaleValue;
                  const pageNumber = firstPage.id;
                  const currentPageView = this._pages[pageNumber - 1];
                  const container = this.container;
                  const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
                  const intLeft = Math.round(topLeft[0]);
                  const intTop = Math.round(topLeft[1]);
                  let pdfOpenParams = `#page=${pageNumber}`;
                  if (!this.isInPresentationMode) {
                    pdfOpenParams += `&zoom=${normalizedScaleValue},${intLeft},${intTop}`;
                  }
                  this._location = {
                    pageNumber,
                    scale: normalizedScaleValue,
                    top: intTop,
                    left: intLeft,
                    rotation: this._pagesRotation,
                    pdfOpenParams
                  };
                }
                update() {
                  const visible = this._getVisiblePages();
                  const visiblePages = visible.views, numVisiblePages = visiblePages.length;
                  if (numVisiblePages === 0) {
                    return;
                  }
                  const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
                  __privateGet(this, _buffer).resize(newCacheSize, visible.ids);
                  this.renderingQueue.renderHighestPriority(visible);
                  const isSimpleLayout = this._spreadMode === _ui_utils.SpreadMode.NONE && (this._scrollMode === _ui_utils.ScrollMode.PAGE || this._scrollMode === _ui_utils.ScrollMode.VERTICAL);
                  const currentId = this._currentPageNumber;
                  let stillFullyVisible = false;
                  for (const page of visiblePages) {
                    if (page.percent < 100) {
                      break;
                    }
                    if (page.id === currentId && isSimpleLayout) {
                      stillFullyVisible = true;
                      break;
                    }
                  }
                  this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id);
                  this._updateLocation(visible.first);
                  this.eventBus.dispatch("updateviewarea", {
                    source: this,
                    location: this._location
                  });
                }
                containsElement(element) {
                  return this.container.contains(element);
                }
                focus() {
                  this.container.focus();
                }
                get _isContainerRtl() {
                  return getComputedStyle(this.container).direction === "rtl";
                }
                get isInPresentationMode() {
                  return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
                }
                get isChangingPresentationMode() {
                  return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
                }
                get isHorizontalScrollbarEnabled() {
                  return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
                }
                get isVerticalScrollbarEnabled() {
                  return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
                }
                _getVisiblePages() {
                  const views = this._scrollMode === _ui_utils.ScrollMode.PAGE ? __privateGet(this, _scrollModePageState).pages : this._pages, horizontal = this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl;
                  return (0, _ui_utils.getVisibleElements)({
                    scrollEl: this.container,
                    views,
                    sortByVisibility: true,
                    horizontal,
                    rtl
                  });
                }
                cleanup() {
                  for (const pageView of this._pages) {
                    if (pageView.renderingState !== _ui_utils.RenderingStates.FINISHED) {
                      pageView.reset();
                    }
                  }
                }
                _cancelRendering() {
                  for (const pageView of this._pages) {
                    pageView.cancelRendering();
                  }
                }
                forceRendering(currentlyVisiblePages) {
                  const visiblePages = currentlyVisiblePages || this._getVisiblePages();
                  const scrollAhead = __privateMethod(this, _getScrollAhead, getScrollAhead_fn).call(this, visiblePages);
                  const preRenderExtra = this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL;
                  const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);
                  if (pageView) {
                    __privateMethod(this, _ensurePdfPageLoaded, ensurePdfPageLoaded_fn).call(this, pageView).then(() => {
                      this.renderingQueue.renderView(pageView);
                    });
                    return true;
                  }
                  return false;
                }
                get hasEqualPageSizes() {
                  const firstPageView = this._pages[0];
                  for (let i = 1, ii = this._pages.length; i < ii; ++i) {
                    const pageView = this._pages[i];
                    if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
                      return false;
                    }
                  }
                  return true;
                }
                getPagesOverview() {
                  let initialOrientation;
                  return this._pages.map((pageView) => {
                    const viewport = pageView.pdfPage.getViewport({
                      scale: 1
                    });
                    const orientation = (0, _ui_utils.isPortraitOrientation)(viewport);
                    if (initialOrientation === void 0) {
                      initialOrientation = orientation;
                    } else if (this.enablePrintAutoRotate && orientation !== initialOrientation) {
                      return {
                        width: viewport.height,
                        height: viewport.width,
                        rotation: (viewport.rotation - 90) % 360
                      };
                    }
                    return {
                      width: viewport.width,
                      height: viewport.height,
                      rotation: viewport.rotation
                    };
                  });
                }
                get optionalContentConfigPromise() {
                  if (!this.pdfDocument) {
                    return Promise.resolve(null);
                  }
                  if (!this._optionalContentConfigPromise) {
                    console.error("optionalContentConfigPromise: Not initialized yet.");
                    return this.pdfDocument.getOptionalContentConfig();
                  }
                  return this._optionalContentConfigPromise;
                }
                set optionalContentConfigPromise(promise) {
                  if (!(promise instanceof Promise)) {
                    throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  if (!this._optionalContentConfigPromise) {
                    return;
                  }
                  this._optionalContentConfigPromise = promise;
                  this.refresh(false, {
                    optionalContentConfigPromise: promise
                  });
                  this.eventBus.dispatch("optionalcontentconfigchanged", {
                    source: this,
                    promise
                  });
                }
                get scrollMode() {
                  return this._scrollMode;
                }
                set scrollMode(mode) {
                  if (this._scrollMode === mode) {
                    return;
                  }
                  if (!(0, _ui_utils.isValidScrollMode)(mode)) {
                    throw new Error(`Invalid scroll mode: ${mode}`);
                  }
                  if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
                    return;
                  }
                  this._previousScrollMode = this._scrollMode;
                  this._scrollMode = mode;
                  this.eventBus.dispatch("scrollmodechanged", {
                    source: this,
                    mode
                  });
                  this._updateScrollMode(this._currentPageNumber);
                }
                _updateScrollMode(pageNumber = null) {
                  const scrollMode = this._scrollMode, viewer = this.viewer;
                  viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
                  viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);
                  if (!this.pdfDocument || !pageNumber) {
                    return;
                  }
                  if (scrollMode === _ui_utils.ScrollMode.PAGE) {
                    __privateMethod(this, _ensurePageViewVisible, ensurePageViewVisible_fn).call(this);
                  } else if (this._previousScrollMode === _ui_utils.ScrollMode.PAGE) {
                    this._updateSpreadMode();
                  }
                  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                    __privateMethod(this, _setScale, setScale_fn).call(this, this._currentScaleValue, {
                      noScroll: true
                    });
                  }
                  this._setCurrentPageNumber(pageNumber, true);
                  this.update();
                }
                get spreadMode() {
                  return this._spreadMode;
                }
                set spreadMode(mode) {
                  if (this._spreadMode === mode) {
                    return;
                  }
                  if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
                    throw new Error(`Invalid spread mode: ${mode}`);
                  }
                  this._spreadMode = mode;
                  this.eventBus.dispatch("spreadmodechanged", {
                    source: this,
                    mode
                  });
                  this._updateSpreadMode(this._currentPageNumber);
                }
                _updateSpreadMode(pageNumber = null) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  const viewer = this.viewer, pages = this._pages;
                  if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                    __privateMethod(this, _ensurePageViewVisible, ensurePageViewVisible_fn).call(this);
                  } else {
                    viewer.textContent = "";
                    if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                      for (const pageView of this._pages) {
                        viewer.append(pageView.div);
                      }
                    } else {
                      const parity = this._spreadMode - 1;
                      let spread = null;
                      for (let i = 0, ii = pages.length; i < ii; ++i) {
                        if (spread === null) {
                          spread = document.createElement("div");
                          spread.className = "spread";
                          viewer.append(spread);
                        } else if (i % 2 === parity) {
                          spread = spread.cloneNode(false);
                          viewer.append(spread);
                        }
                        spread.append(pages[i].div);
                      }
                    }
                  }
                  if (!pageNumber) {
                    return;
                  }
                  if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                    __privateMethod(this, _setScale, setScale_fn).call(this, this._currentScaleValue, {
                      noScroll: true
                    });
                  }
                  this._setCurrentPageNumber(pageNumber, true);
                  this.update();
                }
                _getPageAdvance(currentPageNumber, previous = false) {
                  switch (this._scrollMode) {
                    case _ui_utils.ScrollMode.WRAPPED: {
                      const {
                        views
                      } = this._getVisiblePages(), pageLayout = /* @__PURE__ */ new Map();
                      for (const {
                        id,
                        y,
                        percent,
                        widthPercent
                      } of views) {
                        if (percent === 0 || widthPercent < 100) {
                          continue;
                        }
                        let yArray = pageLayout.get(y);
                        if (!yArray) {
                          pageLayout.set(y, yArray || (yArray = []));
                        }
                        yArray.push(id);
                      }
                      for (const yArray of pageLayout.values()) {
                        const currentIndex = yArray.indexOf(currentPageNumber);
                        if (currentIndex === -1) {
                          continue;
                        }
                        const numPages = yArray.length;
                        if (numPages === 1) {
                          break;
                        }
                        if (previous) {
                          for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {
                            const currentId = yArray[i], expectedId = yArray[i + 1] - 1;
                            if (currentId < expectedId) {
                              return currentPageNumber - expectedId;
                            }
                          }
                        } else {
                          for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {
                            const currentId = yArray[i], expectedId = yArray[i - 1] + 1;
                            if (currentId > expectedId) {
                              return expectedId - currentPageNumber;
                            }
                          }
                        }
                        if (previous) {
                          const firstId = yArray[0];
                          if (firstId < currentPageNumber) {
                            return currentPageNumber - firstId + 1;
                          }
                        } else {
                          const lastId = yArray[numPages - 1];
                          if (lastId > currentPageNumber) {
                            return lastId - currentPageNumber + 1;
                          }
                        }
                        break;
                      }
                      break;
                    }
                    case _ui_utils.ScrollMode.HORIZONTAL: {
                      break;
                    }
                    case _ui_utils.ScrollMode.PAGE:
                    case _ui_utils.ScrollMode.VERTICAL: {
                      if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                        break;
                      }
                      const parity = this._spreadMode - 1;
                      if (previous && currentPageNumber % 2 !== parity) {
                        break;
                      } else if (!previous && currentPageNumber % 2 === parity) {
                        break;
                      }
                      const {
                        views
                      } = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;
                      for (const {
                        id,
                        percent,
                        widthPercent
                      } of views) {
                        if (id !== expectedId) {
                          continue;
                        }
                        if (percent > 0 && widthPercent === 100) {
                          return 2;
                        }
                        break;
                      }
                      break;
                    }
                  }
                  return 1;
                }
                nextPage() {
                  const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount;
                  if (currentPageNumber >= pagesCount) {
                    return false;
                  }
                  const advance = this._getPageAdvance(currentPageNumber, false) || 1;
                  this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
                  return true;
                }
                previousPage() {
                  const currentPageNumber = this._currentPageNumber;
                  if (currentPageNumber <= 1) {
                    return false;
                  }
                  const advance = this._getPageAdvance(currentPageNumber, true) || 1;
                  this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
                  return true;
                }
                increaseScale({
                  drawingDelay,
                  scaleFactor,
                  steps
                } = {}) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let newScale = this._currentScale;
                  if (scaleFactor > 1) {
                    newScale = Math.round(newScale * scaleFactor * 100) / 100;
                  } else {
                    steps ?? (steps = 1);
                    do {
                      newScale = Math.ceil((newScale * _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                    } while (--steps > 0 && newScale < _ui_utils.MAX_SCALE);
                  }
                  __privateMethod(this, _setScale, setScale_fn).call(this, Math.min(_ui_utils.MAX_SCALE, newScale), {
                    noScroll: false,
                    drawingDelay
                  });
                }
                decreaseScale({
                  drawingDelay,
                  scaleFactor,
                  steps
                } = {}) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  let newScale = this._currentScale;
                  if (scaleFactor > 0 && scaleFactor < 1) {
                    newScale = Math.round(newScale * scaleFactor * 100) / 100;
                  } else {
                    steps ?? (steps = 1);
                    do {
                      newScale = Math.floor((newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                    } while (--steps > 0 && newScale > _ui_utils.MIN_SCALE);
                  }
                  __privateMethod(this, _setScale, setScale_fn).call(this, Math.max(_ui_utils.MIN_SCALE, newScale), {
                    noScroll: false,
                    drawingDelay
                  });
                }
                get containerTopLeft() {
                  return __privateGet(this, _containerTopLeft) || __privateSet(this, _containerTopLeft, [this.container.offsetTop, this.container.offsetLeft]);
                }
                get annotationEditorMode() {
                  return __privateGet(this, _annotationEditorUIManager) ? __privateGet(this, _annotationEditorMode) : _pdfjsLib.AnnotationEditorType.DISABLE;
                }
                set annotationEditorMode({
                  mode,
                  editId = null
                }) {
                  if (!__privateGet(this, _annotationEditorUIManager)) {
                    throw new Error(`The AnnotationEditor is not enabled.`);
                  }
                  if (__privateGet(this, _annotationEditorMode) === mode) {
                    return;
                  }
                  if (!isValidAnnotationEditorMode(mode)) {
                    throw new Error(`Invalid AnnotationEditor mode: ${mode}`);
                  }
                  if (!this.pdfDocument) {
                    return;
                  }
                  __privateSet(this, _annotationEditorMode, mode);
                  this.eventBus.dispatch("annotationeditormodechanged", {
                    source: this,
                    mode
                  });
                  __privateGet(this, _annotationEditorUIManager).updateMode(mode, editId);
                }
                set annotationEditorParams({
                  type,
                  value
                }) {
                  if (!__privateGet(this, _annotationEditorUIManager)) {
                    throw new Error(`The AnnotationEditor is not enabled.`);
                  }
                  __privateGet(this, _annotationEditorUIManager).updateParams(type, value);
                }
                refresh(noUpdate = false, updateArgs = /* @__PURE__ */ Object.create(null)) {
                  if (!this.pdfDocument) {
                    return;
                  }
                  for (const pageView of this._pages) {
                    pageView.update(updateArgs);
                  }
                  if (__privateGet(this, _scaleTimeoutId) !== null) {
                    clearTimeout(__privateGet(this, _scaleTimeoutId));
                    __privateSet(this, _scaleTimeoutId, null);
                  }
                  if (!noUpdate) {
                    this.update();
                  }
                }
              }
              _buffer = new WeakMap();
              _annotationEditorMode = new WeakMap();
              _annotationEditorUIManager = new WeakMap();
              _annotationMode = new WeakMap();
              _containerTopLeft = new WeakMap();
              _copyCallbackBound = new WeakMap();
              _enablePermissions = new WeakMap();
              _getAllTextInProgress = new WeakMap();
              _hiddenCopyElement = new WeakMap();
              _interruptCopyCondition = new WeakMap();
              _previousContainerHeight = new WeakMap();
              _resizeObserver = new WeakMap();
              _scrollModePageState = new WeakMap();
              _onVisibilityChange = new WeakMap();
              _scaleTimeoutId = new WeakMap();
              _textLayerMode = new WeakMap();
              _layerProperties = new WeakSet();
              layerProperties_fn = function() {
                const self = this;
                return {
                  get annotationEditorUIManager() {
                    return __privateGet(self, _annotationEditorUIManager);
                  },
                  get annotationStorage() {
                    var _a;
                    return (_a = self.pdfDocument) == null ? void 0 : _a.annotationStorage;
                  },
                  get downloadManager() {
                    return self.downloadManager;
                  },
                  get enableScripting() {
                    return !!self._scriptingManager;
                  },
                  get fieldObjectsPromise() {
                    var _a;
                    return (_a = self.pdfDocument) == null ? void 0 : _a.getFieldObjects();
                  },
                  get findController() {
                    return self.findController;
                  },
                  get hasJSActionsPromise() {
                    var _a;
                    return (_a = self.pdfDocument) == null ? void 0 : _a.hasJSActions();
                  },
                  get linkService() {
                    return self.linkService;
                  }
                };
              };
              _initializePermissions = new WeakSet();
              initializePermissions_fn = function(permissions) {
                const params = {
                  annotationEditorMode: __privateGet(this, _annotationEditorMode),
                  annotationMode: __privateGet(this, _annotationMode),
                  textLayerMode: __privateGet(this, _textLayerMode)
                };
                if (!permissions) {
                  return params;
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY) && __privateGet(this, _textLayerMode) === _ui_utils.TextLayerMode.ENABLE) {
                  params.textLayerMode = _ui_utils.TextLayerMode.ENABLE_PERMISSIONS;
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_CONTENTS)) {
                  params.annotationEditorMode = _pdfjsLib.AnnotationEditorType.DISABLE;
                }
                if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(_pdfjsLib.PermissionFlag.FILL_INTERACTIVE_FORMS) && __privateGet(this, _annotationMode) === _pdfjsLib.AnnotationMode.ENABLE_FORMS) {
                  params.annotationMode = _pdfjsLib.AnnotationMode.ENABLE;
                }
                return params;
              };
              _onePageRenderedOrForceFetch = new WeakSet();
              onePageRenderedOrForceFetch_fn = function() {
                if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {
                  return Promise.resolve();
                }
                const visibilityChangePromise = new Promise((resolve) => {
                  __privateSet(this, _onVisibilityChange, () => {
                    if (document.visibilityState !== "hidden") {
                      return;
                    }
                    resolve();
                    document.removeEventListener("visibilitychange", __privateGet(this, _onVisibilityChange));
                    __privateSet(this, _onVisibilityChange, null);
                  });
                  document.addEventListener("visibilitychange", __privateGet(this, _onVisibilityChange));
                });
                return Promise.race([this._onePageRenderedCapability.promise, visibilityChangePromise]);
              };
              _copyCallback = new WeakSet();
              copyCallback_fn = function(textLayerMode, event) {
                const selection = document.getSelection();
                const {
                  focusNode,
                  anchorNode
                } = selection;
                if (anchorNode && focusNode && selection.containsNode(__privateGet(this, _hiddenCopyElement))) {
                  if (__privateGet(this, _getAllTextInProgress) || textLayerMode === _ui_utils.TextLayerMode.ENABLE_PERMISSIONS) {
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                  }
                  __privateSet(this, _getAllTextInProgress, true);
                  const savedCursor = this.container.style.cursor;
                  this.container.style.cursor = "wait";
                  const interruptCopy = (ev) => __privateSet(this, _interruptCopyCondition, ev.key === "Escape");
                  window.addEventListener("keydown", interruptCopy);
                  this.getAllText().then(async (text) => {
                    if (text !== null) {
                      await navigator.clipboard.writeText(text);
                    }
                  }).catch((reason) => {
                    console.warn(`Something goes wrong when extracting the text: ${reason.message}`);
                  }).finally(() => {
                    __privateSet(this, _getAllTextInProgress, false);
                    __privateSet(this, _interruptCopyCondition, false);
                    window.removeEventListener("keydown", interruptCopy);
                    this.container.style.cursor = savedCursor;
                  });
                  event.preventDefault();
                  event.stopPropagation();
                }
              };
              _ensurePageViewVisible = new WeakSet();
              ensurePageViewVisible_fn = function() {
                if (this._scrollMode !== _ui_utils.ScrollMode.PAGE) {
                  throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
                }
                const pageNumber = this._currentPageNumber, state = __privateGet(this, _scrollModePageState), viewer = this.viewer;
                viewer.textContent = "";
                state.pages.length = 0;
                if (this._spreadMode === _ui_utils.SpreadMode.NONE && !this.isInPresentationMode) {
                  const pageView = this._pages[pageNumber - 1];
                  viewer.append(pageView.div);
                  state.pages.push(pageView);
                } else {
                  const pageIndexSet = /* @__PURE__ */ new Set(), parity = this._spreadMode - 1;
                  if (parity === -1) {
                    pageIndexSet.add(pageNumber - 1);
                  } else if (pageNumber % 2 !== parity) {
                    pageIndexSet.add(pageNumber - 1);
                    pageIndexSet.add(pageNumber);
                  } else {
                    pageIndexSet.add(pageNumber - 2);
                    pageIndexSet.add(pageNumber - 1);
                  }
                  const spread = document.createElement("div");
                  spread.className = "spread";
                  if (this.isInPresentationMode) {
                    const dummyPage = document.createElement("div");
                    dummyPage.className = "dummyPage";
                    spread.append(dummyPage);
                  }
                  for (const i of pageIndexSet) {
                    const pageView = this._pages[i];
                    if (!pageView) {
                      continue;
                    }
                    spread.append(pageView.div);
                    state.pages.push(pageView);
                  }
                  viewer.append(spread);
                }
                state.scrollDown = pageNumber >= state.previousPageNumber;
                state.previousPageNumber = pageNumber;
              };
              _scrollIntoView = new WeakSet();
              scrollIntoView_fn = function(pageView, pageSpot = null) {
                const {
                  div,
                  id
                } = pageView;
                if (this._currentPageNumber !== id) {
                  this._setCurrentPageNumber(id);
                }
                if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
                  __privateMethod(this, _ensurePageViewVisible, ensurePageViewVisible_fn).call(this);
                  this.update();
                }
                if (!pageSpot && !this.isInPresentationMode) {
                  const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth;
                  const {
                    scrollLeft,
                    clientWidth
                  } = this.container;
                  if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {
                    pageSpot = {
                      left: 0,
                      top: 0
                    };
                  }
                }
                (0, _ui_utils.scrollIntoView)(div, pageSpot);
                if (!this._currentScaleValue && this._location) {
                  this._location = null;
                }
              };
              _isSameScale = new WeakSet();
              isSameScale_fn = function(newScale) {
                return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;
              };
              _setScaleUpdatePages = new WeakSet();
              setScaleUpdatePages_fn = function(newScale, newValue, {
                noScroll = false,
                preset = false,
                drawingDelay = -1
              }) {
                this._currentScaleValue = newValue.toString();
                if (__privateMethod(this, _isSameScale, isSameScale_fn).call(this, newScale)) {
                  if (preset) {
                    this.eventBus.dispatch("scalechanging", {
                      source: this,
                      scale: newScale,
                      presetValue: newValue
                    });
                  }
                  return;
                }
                this.viewer.style.setProperty("--scale-factor", newScale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS);
                const postponeDrawing = drawingDelay >= 0 && drawingDelay < 1e3;
                this.refresh(true, {
                  scale: newScale,
                  drawingDelay: postponeDrawing ? drawingDelay : -1
                });
                if (postponeDrawing) {
                  __privateSet(this, _scaleTimeoutId, setTimeout(() => {
                    __privateSet(this, _scaleTimeoutId, null);
                    this.refresh();
                  }, drawingDelay));
                }
                this._currentScale = newScale;
                if (!noScroll) {
                  let page = this._currentPageNumber, dest;
                  if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
                    page = this._location.pageNumber;
                    dest = [null, {
                      name: "XYZ"
                    }, this._location.left, this._location.top, null];
                  }
                  this.scrollPageIntoView({
                    pageNumber: page,
                    destArray: dest,
                    allowNegativeOffset: true
                  });
                }
                this.eventBus.dispatch("scalechanging", {
                  source: this,
                  scale: newScale,
                  presetValue: preset ? newValue : void 0
                });
                if (this.defaultRenderingQueue) {
                  this.update();
                }
              };
              _pageWidthScaleFactor = new WeakSet();
              pageWidthScaleFactor_get = function() {
                if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL) {
                  return 2;
                }
                return 1;
              };
              _setScale = new WeakSet();
              setScale_fn = function(value, options) {
                let scale = parseFloat(value);
                if (scale > 0) {
                  options.preset = false;
                  __privateMethod(this, _setScaleUpdatePages, setScaleUpdatePages_fn).call(this, scale, value, options);
                } else {
                  const currentPage = this._pages[this._currentPageNumber - 1];
                  if (!currentPage) {
                    return;
                  }
                  let hPadding = _ui_utils.SCROLLBAR_PADDING, vPadding = _ui_utils.VERTICAL_PADDING;
                  if (this.isInPresentationMode) {
                    hPadding = vPadding = 4;
                    if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
                      hPadding *= 2;
                    }
                  } else if (this.removePageBorders) {
                    hPadding = vPadding = 0;
                  } else if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL) {
                    [hPadding, vPadding] = [vPadding, hPadding];
                  }
                  const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / __privateGet(this, _pageWidthScaleFactor, pageWidthScaleFactor_get);
                  const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
                  switch (value) {
                    case "page-actual":
                      scale = 1;
                      break;
                    case "page-width":
                      scale = pageWidthScale;
                      break;
                    case "page-height":
                      scale = pageHeightScale;
                      break;
                    case "page-fit":
                      scale = Math.min(pageWidthScale, pageHeightScale);
                      break;
                    case "auto":
                      const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                      scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                      break;
                    default:
                      console.error(`#setScale: "${value}" is an unknown zoom value.`);
                      return;
                  }
                  options.preset = true;
                  __privateMethod(this, _setScaleUpdatePages, setScaleUpdatePages_fn).call(this, scale, value, options);
                }
              };
              _resetCurrentPageView = new WeakSet();
              resetCurrentPageView_fn = function() {
                const pageView = this._pages[this._currentPageNumber - 1];
                if (this.isInPresentationMode) {
                  __privateMethod(this, _setScale, setScale_fn).call(this, this._currentScaleValue, {
                    noScroll: true
                  });
                }
                __privateMethod(this, _scrollIntoView, scrollIntoView_fn).call(this, pageView);
              };
              _ensurePdfPageLoaded = new WeakSet();
              ensurePdfPageLoaded_fn = async function(pageView) {
                var _a, _b;
                if (pageView.pdfPage) {
                  return pageView.pdfPage;
                }
                try {
                  const pdfPage = await this.pdfDocument.getPage(pageView.id);
                  if (!pageView.pdfPage) {
                    pageView.setPdfPage(pdfPage);
                  }
                  if (!((_b = (_a = this.linkService)._cachedPageNumber) == null ? void 0 : _b.call(_a, pdfPage.ref))) {
                    this.linkService.cachePageRef(pageView.id, pdfPage.ref);
                  }
                  return pdfPage;
                } catch (reason) {
                  console.error("Unable to get page for page view", reason);
                  return null;
                }
              };
              _getScrollAhead = new WeakSet();
              getScrollAhead_fn = function(visible) {
                var _a, _b;
                if (((_a = visible.first) == null ? void 0 : _a.id) === 1) {
                  return true;
                } else if (((_b = visible.last) == null ? void 0 : _b.id) === this.pagesCount) {
                  return false;
                }
                switch (this._scrollMode) {
                  case _ui_utils.ScrollMode.PAGE:
                    return __privateGet(this, _scrollModePageState).scrollDown;
                  case _ui_utils.ScrollMode.HORIZONTAL:
                    return this.scroll.right;
                }
                return this.scroll.down;
              };
              _updateContainerHeightCss = new WeakSet();
              updateContainerHeightCss_fn = function(height = this.container.clientHeight) {
                if (height !== __privateGet(this, _previousContainerHeight)) {
                  __privateSet(this, _previousContainerHeight, height);
                  _ui_utils.docStyle.setProperty("--viewer-container-height", `${height}px`);
                }
              };
              _resizeObserverCallback = new WeakSet();
              resizeObserverCallback_fn = function(entries) {
                for (const entry of entries) {
                  if (entry.target === this.container) {
                    __privateMethod(this, _updateContainerHeightCss, updateContainerHeightCss_fn).call(this, Math.floor(entry.borderBoxSize[0].blockSize));
                    __privateSet(this, _containerTopLeft, null);
                    break;
                  }
                }
              };
              exports2.PDFViewer = PDFViewer;
            },
            /* 26 */
            /***/
            (__unused_webpack_module, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFRenderingQueue = void 0;
              var _pdfjsLib = __w_pdfjs_require__2(4);
              var _ui_utils = __w_pdfjs_require__2(2);
              const CLEANUP_TIMEOUT = 3e4;
              class PDFRenderingQueue {
                constructor() {
                  this.pdfViewer = null;
                  this.pdfThumbnailViewer = null;
                  this.onIdle = null;
                  this.highestPriorityPage = null;
                  this.idleTimeout = null;
                  this.printing = false;
                  this.isThumbnailViewEnabled = false;
                  Object.defineProperty(this, "hasViewer", {
                    value: () => !!this.pdfViewer
                  });
                }
                setViewer(pdfViewer) {
                  this.pdfViewer = pdfViewer;
                }
                setThumbnailViewer(pdfThumbnailViewer) {
                  this.pdfThumbnailViewer = pdfThumbnailViewer;
                }
                isHighestPriority(view) {
                  return this.highestPriorityPage === view.renderingId;
                }
                renderHighestPriority(currentlyVisiblePages) {
                  var _a;
                  if (this.idleTimeout) {
                    clearTimeout(this.idleTimeout);
                    this.idleTimeout = null;
                  }
                  if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
                    return;
                  }
                  if (this.isThumbnailViewEnabled && ((_a = this.pdfThumbnailViewer) == null ? void 0 : _a.forceRendering())) {
                    return;
                  }
                  if (this.printing) {
                    return;
                  }
                  if (this.onIdle) {
                    this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
                  }
                }
                getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) {
                  const visibleViews = visible.views, numVisible = visibleViews.length;
                  if (numVisible === 0) {
                    return null;
                  }
                  for (let i = 0; i < numVisible; i++) {
                    const view = visibleViews[i].view;
                    if (!this.isViewFinished(view)) {
                      return view;
                    }
                  }
                  const firstId = visible.first.id, lastId = visible.last.id;
                  if (lastId - firstId + 1 > numVisible) {
                    const visibleIds = visible.ids;
                    for (let i = 1, ii = lastId - firstId; i < ii; i++) {
                      const holeId = scrolledDown ? firstId + i : lastId - i;
                      if (visibleIds.has(holeId)) {
                        continue;
                      }
                      const holeView = views[holeId - 1];
                      if (!this.isViewFinished(holeView)) {
                        return holeView;
                      }
                    }
                  }
                  let preRenderIndex = scrolledDown ? lastId : firstId - 2;
                  let preRenderView = views[preRenderIndex];
                  if (preRenderView && !this.isViewFinished(preRenderView)) {
                    return preRenderView;
                  }
                  if (preRenderExtra) {
                    preRenderIndex += scrolledDown ? 1 : -1;
                    preRenderView = views[preRenderIndex];
                    if (preRenderView && !this.isViewFinished(preRenderView)) {
                      return preRenderView;
                    }
                  }
                  return null;
                }
                isViewFinished(view) {
                  return view.renderingState === _ui_utils.RenderingStates.FINISHED;
                }
                renderView(view) {
                  switch (view.renderingState) {
                    case _ui_utils.RenderingStates.FINISHED:
                      return false;
                    case _ui_utils.RenderingStates.PAUSED:
                      this.highestPriorityPage = view.renderingId;
                      view.resume();
                      break;
                    case _ui_utils.RenderingStates.RUNNING:
                      this.highestPriorityPage = view.renderingId;
                      break;
                    case _ui_utils.RenderingStates.INITIAL:
                      this.highestPriorityPage = view.renderingId;
                      view.draw().finally(() => {
                        this.renderHighestPriority();
                      }).catch((reason) => {
                        if (reason instanceof _pdfjsLib.RenderingCancelledException) {
                          return;
                        }
                        console.error(`renderView: "${reason}"`);
                      });
                      break;
                  }
                  return true;
                }
              }
              exports2.PDFRenderingQueue = PDFRenderingQueue;
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationLayerBuilder", {
              enumerable: true,
              get: function() {
                return _annotation_layer_builder.AnnotationLayerBuilder;
              }
            });
            Object.defineProperty(exports2, "DownloadManager", {
              enumerable: true,
              get: function() {
                return _download_manager.DownloadManager;
              }
            });
            Object.defineProperty(exports2, "EventBus", {
              enumerable: true,
              get: function() {
                return _event_utils.EventBus;
              }
            });
            Object.defineProperty(exports2, "FindState", {
              enumerable: true,
              get: function() {
                return _pdf_find_controller.FindState;
              }
            });
            Object.defineProperty(exports2, "GenericL10n", {
              enumerable: true,
              get: function() {
                return _genericl10n.GenericL10n;
              }
            });
            Object.defineProperty(exports2, "LinkTarget", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.LinkTarget;
              }
            });
            Object.defineProperty(exports2, "NullL10n", {
              enumerable: true,
              get: function() {
                return _l10n_utils.NullL10n;
              }
            });
            Object.defineProperty(exports2, "PDFFindController", {
              enumerable: true,
              get: function() {
                return _pdf_find_controller.PDFFindController;
              }
            });
            Object.defineProperty(exports2, "PDFHistory", {
              enumerable: true,
              get: function() {
                return _pdf_history.PDFHistory;
              }
            });
            Object.defineProperty(exports2, "PDFLinkService", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.PDFLinkService;
              }
            });
            Object.defineProperty(exports2, "PDFPageView", {
              enumerable: true,
              get: function() {
                return _pdf_page_view.PDFPageView;
              }
            });
            Object.defineProperty(exports2, "PDFScriptingManager", {
              enumerable: true,
              get: function() {
                return _pdf_scripting_managerComponent.PDFScriptingManager;
              }
            });
            Object.defineProperty(exports2, "PDFSinglePageViewer", {
              enumerable: true,
              get: function() {
                return _pdf_single_page_viewer.PDFSinglePageViewer;
              }
            });
            Object.defineProperty(exports2, "PDFViewer", {
              enumerable: true,
              get: function() {
                return _pdf_viewer.PDFViewer;
              }
            });
            Object.defineProperty(exports2, "ProgressBar", {
              enumerable: true,
              get: function() {
                return _ui_utils.ProgressBar;
              }
            });
            Object.defineProperty(exports2, "RenderingStates", {
              enumerable: true,
              get: function() {
                return _ui_utils.RenderingStates;
              }
            });
            Object.defineProperty(exports2, "ScrollMode", {
              enumerable: true,
              get: function() {
                return _ui_utils.ScrollMode;
              }
            });
            Object.defineProperty(exports2, "SimpleLinkService", {
              enumerable: true,
              get: function() {
                return _pdf_link_service.SimpleLinkService;
              }
            });
            Object.defineProperty(exports2, "SpreadMode", {
              enumerable: true,
              get: function() {
                return _ui_utils.SpreadMode;
              }
            });
            Object.defineProperty(exports2, "StructTreeLayerBuilder", {
              enumerable: true,
              get: function() {
                return _struct_tree_layer_builder.StructTreeLayerBuilder;
              }
            });
            Object.defineProperty(exports2, "TextLayerBuilder", {
              enumerable: true,
              get: function() {
                return _text_layer_builder.TextLayerBuilder;
              }
            });
            Object.defineProperty(exports2, "XfaLayerBuilder", {
              enumerable: true,
              get: function() {
                return _xfa_layer_builder.XfaLayerBuilder;
              }
            });
            Object.defineProperty(exports2, "parseQueryString", {
              enumerable: true,
              get: function() {
                return _ui_utils.parseQueryString;
              }
            });
            var _pdf_find_controller = __w_pdfjs_require__(1);
            var _pdf_link_service = __w_pdfjs_require__(5);
            var _ui_utils = __w_pdfjs_require__(2);
            var _annotation_layer_builder = __w_pdfjs_require__(6);
            var _download_manager = __w_pdfjs_require__(8);
            var _event_utils = __w_pdfjs_require__(9);
            var _genericl10n = __w_pdfjs_require__(10);
            var _l10n_utils = __w_pdfjs_require__(7);
            var _pdf_history = __w_pdfjs_require__(12);
            var _pdf_page_view = __w_pdfjs_require__(13);
            var _pdf_scripting_managerComponent = __w_pdfjs_require__(21);
            var _pdf_single_page_viewer = __w_pdfjs_require__(24);
            var _pdf_viewer = __w_pdfjs_require__(25);
            var _struct_tree_layer_builder = __w_pdfjs_require__(16);
            var _text_layer_builder = __w_pdfjs_require__(19);
            var _xfa_layer_builder = __w_pdfjs_require__(20);
            const pdfjsVersion = "3.10.111";
            const pdfjsBuild = "e142baecb";
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_pdf_viewer();
//# sourceMappingURL=pdfjs-dist_web_pdf_viewer.js.map
